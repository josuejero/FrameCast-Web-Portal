.
├── FrameCast - FInal.textClipping
├── LICENSE
├── README.md
├── __tests__
│   └── photo-editor-app.test.js
├── agent
│   ├── code_distributor.py
│   ├── controller
│   │   ├── displayed_photo
│   │   ├── frame_controller.py
│   │   └── logo.jpg
│   ├── run.py
│   ├── web
│   │   └── web_server.py
│   └── wireless
│       ├── bluetooth_connection.py
│       └── wifi_connection.py
├── app.py
├── concat_files.sh
├── controller
│   ├── __pycache__
│   │   ├── frame_controller.cpython-311.pyc
│   │   └── frame_controller.cpython-37.pyc
│   ├── displayed_photo
│   │   ├── current.jpg
│   │   └── next.jpg
│   ├── frame_controller.py
│   ├── frame_controller_original.py
│   ├── hostname_display.jpg
│   └── logo.jpg
├── device_config.json
├── device_config_backup.json
├── device_config_backup2.json
├── digital_photo_frame_config.json
├── instance
│   └── photos.db
├── jest.config.js
├── jest.setup.js
├── migrations
│   ├── README
│   ├── alembic.ini
│   ├── env.py
│   ├── script.py.mako
│   └── versions
│       ├── 2024-06-12_add_split_screen_to_photo.py
│       ├── 4ab810f9beb5_initial_migration.py
│       └── c7e6147d997f_add_photo_update_frequency_and_random_.py
├── output.txt
├── package-lock.json
├── package.json
├── photo_config.json
├── photo_config_backup.json
├── photo_frame.db
├── photo_library
│   ├── 416.png
│   ├── Backup
│   │   ├── photo_1.jpg
│   │   ├── photo_2.jpg
│   │   ├── photo_3.jpg
│   │   ├── photo_4.jpg
│   │   ├── photo_5.jpg
│   │   ├── photo_6.jpg
│   │   ├── photo_7.jpg
│   │   └── photo_8.jpg
│   ├── FvcNHSlZ7N.jpg
│   ├── JFXmfbO2Us.jpg
│   ├── Pkroj66an4.jpg
│   ├── VMNx4GiCdR.jpg
│   ├── fS62c2xUWT.jpg
│   ├── iCX17AHy6U.jpg
│   ├── kIq6e2IxYh.jpg
│   ├── mpBSMKE4D8.jpg
│   ├── pVjzOkvFUI.jpg
│   └── photo_test.jpg
├── photos.db
├── principal
│   ├── __pycache__
│   │   ├── agent_manager.cpython-311.pyc
│   │   ├── agent_manager.cpython-37.pyc
│   │   ├── framecast_classes.cpython-311.pyc
│   │   ├── framecast_classes.cpython-37.pyc
│   │   ├── photo_formatter.cpython-311.pyc
│   │   ├── photo_formatter.cpython-37.pyc
│   │   ├── scp_connection_manager.cpython-311.pyc
│   │   └── scp_connection_manager.cpython-37.pyc
│   ├── agent_manager(1).py
│   ├── agent_manager.py
│   ├── current(1).jpg
│   ├── current.jpg
│   ├── formatted_photos
│   │   ├── FvcNHSlZ7N.jpg
│   │   ├── JFXmfbO2Us.jpg
│   │   ├── VMNx4GiCdR.jpg
│   │   ├── iCX17AHy6U.jpg
│   │   ├── kIq6e2IxYh.jpg
│   │   ├── pVjzOkvFUI.jpg
│   │   ├── photo_1.jpg
│   │   ├── photo_2.jpg
│   │   └── photo_3.jpg
│   ├── framecast_classes.py
│   ├── jsonDeviceConfigTest(1).json
│   ├── jsonDeviceConfigTest.json
│   ├── jsonPhotoConfigTest.json
│   ├── photo_formatter(1).py
│   ├── photo_formatter.py
│   ├── principal_manager.py
│   └── scp_connection_manager.py
├── problem.py
├── run.py
├── splash.png
├── static
│   ├── app.js
│   ├── device-editor-app.js
│   ├── favicon.ico
│   ├── photo-editor-app.js
│   ├── style.css
│   ├── style_device_editor.css
│   └── style_photo_editor.css
├── templates
│   ├── device_editor.html
│   ├── index.html
│   └── photo_editor.html
├── test
│   ├── GUI_Test3.py
│   ├── blend_transition_frame_controller.py
│   ├── bluetooth_discover_test.py
│   ├── bluetooth_test.py
│   ├── bluetoothsocket.py
│   ├── create_image.py
│   ├── gpio_test.py
│   ├── hostname_display.jpg
│   ├── logo.jpg
│   ├── logo_edit.jpg
│   ├── photo_1.jpg
│   ├── photo_2.jpg
│   ├── photo_3.jpg
│   ├── photo_edit.jpg
│   ├── photo_format_test.py
│   ├── photo_test.jpg
│   └── random_string.py
├── test_app.py
├── test_config.py
├── test_db.py
├── test_device_model.py
├── web
│   ├── __pycache__
│   │   ├── web_server.cpython-311.pyc
│   │   └── web_server.cpython-37.pyc
│   ├── picture.jpg
│   ├── static
│   │   ├── device_editor.css
│   │   ├── device_editor.js
│   │   ├── device_manager.css
│   │   ├── device_manager.js
│   │   ├── photo_editor.css
│   │   └── photo_editor.js
│   ├── templates
│   │   ├── device_editor.html
│   │   ├── device_manager.html
│   │   └── photo_editor.html
│   ├── update_dns.py
│   └── web_server.py
└── wireless
    ├── __pycache__
    │   ├── api.cpython-311.pyc
    │   ├── bluetooth_manager.cpython-311.pyc
    │   └── wifi_manager.cpython-311.pyc
    ├── api.py
    ├── bluetooth_connection.py
    ├── bluetooth_connection_TESTED.py
    ├── bluetooth_manager.py
    ├── bluetooth_manager_TESTED.py
    ├── bluetoothsocket.py
    ├── bluetoothsocketUpd.py
    ├── wifi_connection.py
    └── wifi_manager.py

27 directories, 150 files

Files sorted by the number of lines:
./principal/framecast_classes.py: 629 lines
./web/static/device_editor.js: 525 lines
./app.py: 331 lines
./web/static/photo_editor.js: 303 lines
./web/web_server.py: 289 lines
./web/static/photo_editor.css: 259 lines
./web/static/device_manager.js: 256 lines
./web/static/device_editor.css: 237 lines
./static/photo-editor-app.js: 231 lines
./static/style_photo_editor.css: 221 lines
./static/style_device_editor.css: 214 lines
./web/static/device_manager.css: 188 lines
./agent/controller/frame_controller.py: 188 lines
./controller/frame_controller.py: 188 lines
./static/device-editor-app.js: 185 lines
./static/style.css: 152 lines
./wireless/wifi_manager.py: 147 lines
./wireless/bluetooth_manager.py: 147 lines
./controller/frame_controller_original.py: 142 lines
./wireless/bluetooth_manager_TESTED.py: 135 lines
./test/GUI_Test3.py: 127 lines
./wireless/bluetoothsocketUpd.py: 126 lines
./migrations/env.py: 113 lines
./digital_photo_frame_config.json: 108 lines
./test_device_model.py: 106 lines
./test/blend_transition_frame_controller.py: 106 lines
./agent/code_distributor.py: 106 lines
./principal/agent_manager.py: 99 lines
./principal/photo_formatter(1).py: 98 lines
./principal/photo_formatter.py: 98 lines
./photo_config.json: 92 lines
./web/templates/device_editor.html: 89 lines
./principal/agent_manager(1).py: 88 lines
./agent/wireless/bluetooth_connection.py: 88 lines
./wireless/bluetooth_connection.py: 88 lines
./principal/scp_connection_manager.py: 85 lines
./photo_config_backup.json: 82 lines
./static/app.js: 81 lines
./templates/device_editor.html: 80 lines
./wireless/bluetoothsocket.py: 75 lines
./test/bluetoothsocket.py: 73 lines
./test/photo_format_test.py: 67 lines
./__tests__/photo-editor-app.test.js: 65 lines
./problem.py: 61 lines
./migrations/versions/4ab810f9beb5_initial_migration.py: 61 lines
./web/templates/photo_editor.html: 61 lines
./wireless/bluetooth_connection_TESTED.py: 59 lines
./web/templates/device_manager.html: 56 lines
./principal/principal_manager.py: 54 lines
./templates/photo_editor.html: 54 lines
./templates/index.html: 53 lines
./test_app.py: 52 lines
./device_config.json: 50 lines
./wireless/wifi_connection.py: 43 lines
./web/update_dns.py: 40 lines
./agent/wireless/wifi_connection.py: 40 lines
./test/create_image.py: 36 lines
./migrations/versions/c7e6147d997f_add_photo_update_frequency_and_random_.py: 34 lines
./test_db.py: 33 lines
./principal/jsonPhotoConfigTest.json: 32 lines
./run.py: 28 lines
./device_config_backup.json: 28 lines
./device_config_backup2.json: 26 lines
./principal/jsonDeviceConfigTest.json: 26 lines
./principal/jsonDeviceConfigTest(1).json: 26 lines
./agent/run.py: 26 lines
./test/gpio_test.py: 23 lines
./migrations/versions/2024-06-12_add_split_screen_to_photo.py: 19 lines
./wireless/api.py: 15 lines
./agent/web/web_server.py: 14 lines
./test/bluetooth_test.py: 13 lines
./test_config.py: 8 lines
./test/bluetooth_discover_test.py: 8 lines
./test/random_string.py: 7 lines
./package.json: 6 lines
./jest.setup.js: 5 lines
./jest.config.js: 4 lines


################################################################################
File: ./test_device_model.py
# test_device_model.py
import unittest
from app import app, db, Device
from test_config import TestConfig

class DeviceModelTestCase(unittest.TestCase):
    """
    A test case for the Device model in the Flask application.
    """

    def setUp(self):
        """
        Set up the test client and initialize the database before each test.
        """
        app.config.from_object(TestConfig)
        self.app = app.test_client()
        with app.app_context():
            db.create_all()

    def tearDown(self):
        """
        Remove the database session and drop all tables after each test.
        """
        with app.app_context():
            db.session.remove()
            db.drop_all()

    def test_create_device(self):
        """
        Test creating a new device in the database.
        """
        with app.app_context():
            new_device = Device(
                device_name="Test Device",
                device_type="Agent",
                status="Online",
                ip_address="192.168.1.1"
            )
            db.session.add(new_device)
            db.session.commit()
            self.assertIsNotNone(new_device.id)
            self.assertEqual(new_device.device_name, "Test Device")
            print(f"Created device with ID: {new_device.id}")

    def test_read_device(self):
        """
        Test reading a device from the database.
        """
        with app.app_context():
            new_device = Device(
                device_name="Test Device",
                device_type="Agent",
                status="Online",
                ip_address="192.168.1.1"
            )
            db.session.add(new_device)
            db.session.commit()
            device = Device.query.filter_by(device_name="Test Device").first()
            self.assertIsNotNone(device)
            self.assertEqual(device.device_name, "Test Device")
            print(f"Read device with ID: {device.id}")

    def test_update_device(self):
        """
        Test updating a device in the database.
        """
        with app.app_context():
            new_device = Device(
                device_name="Test Device",
                device_type="Agent",
                status="Online",
                ip_address="192.168.1.1"
            )
            db.session.add(new_device)
            db.session.commit()
            device = Device.query.filter_by(device_name="Test Device").first()
            self.assertIsNotNone(device)
            device.status = "Offline"
            db.session.commit()
            updated_device = Device.query.filter_by(device_name="Test Device").first()
            self.assertEqual(updated_device.status, "Offline")
            print(f"Updated device with ID: {updated_device.id}")

    def test_delete_device(self):
        """
        Test deleting a device from the database.
        """
        with app.app_context():
            new_device = Device(
                device_name="Test Device",
                device_type="Agent",
                status="Online",
                ip_address="192.168.1.1"
            )
            db.session.add(new_device)
            db.session.commit()
            device = Device.query.filter_by(device_name="Test Device").first()
            self.assertIsNotNone(device)
            db.session.delete(device)
            db.session.commit()
            deleted_device = Device.query.filter_by(device_name="Test Device").first()
            self.assertIsNone(deleted_device)
            print("Deleted device successfully")

if __name__ == '__main__':
    unittest.main()


################################################################################
File: ./run.py
import time
import threading
from principal.agent_manager import run_agent_manager
from controller.frame_controller import start_frame_controller
from web.web_server import start_web_server

def main():

	agent_manager_thread = threading.Thread(target=run_agent_manager)
	agent_manager_thread.daemon = True
	agent_manager_thread.start()
	
	web_server_thread = threading.Thread(target=start_web_server)
	web_server_thread.daemon = True
	web_server_thread.start()
	
	start_frame_controller()
	
	
	'''try:
		while True:
			time.sleep(1)
	except KeyboardInterrupt:
		print("Main application is shutting down...")'''


if __name__ == '__main__':
	main()


################################################################################
File: ./device_config_backup.json
[
    {
        "MAC Address": "NA",
        "Host Name": "FrameCast-v0.1-Principal-00001",
        "Serial Number": "00001",
        "Name": "My New Device (S/N: 00001)",
        "Type": "Principal",
        "IP Address": "10.0.0.35",
        "Connected": true,
        "Update Frequency": 15,
        "Randomize": true,
        "Photo List": []
    },
    {
        "MAC Address": "b8:27:eb:7e:ce:7b",
        "Host Name": "DPF-Eco-Agent-00002",
        "Serial Number": "00002",
        "Name": "My New Device (S/N: 00002)",
        "Type": "Agent",
        "IP Address": "10.0.0.39",
        "Connected": false,
        "Update Frequency": 15,
        "Randomize": true,
        "Photo List": [
            "photo_1.jpg"
        ]
    }
]


################################################################################
File: ./jest.setup.js
const { execSync } = require('child_process');

// Start XVFB before running the tests
execSync('Xvfb :99 -screen 0 1024x768x24 &', { stdio: 'inherit' });
process.env.DISPLAY = ':99';


################################################################################
File: ./test_db.py
from app import app, db, Photo

# Ensure the app context is available
with app.app_context():
    # Create a new photo
    new_photo = Photo(photo_name="Test Photo", path="/path/to/test_photo.jpg")
    db.session.add(new_photo)
    db.session.commit()
    print(f"Created photo: {new_photo.photo_name}, Path: {new_photo.path}")

    # Read the photo
    photo = Photo.query.first()
    if photo:
        print(f"Photo: {photo.photo_name}, Path: {photo.path}")

        # Update the photo
        photo.rotation = 90
        db.session.commit()
        updated_photo = Photo.query.first()
        print(f"Updated Photo Rotation: {updated_photo.rotation}")

        # Delete the photo
        db.session.delete(photo)
        db.session.commit()

        # Verify deletion
        deleted_photo = Photo.query.first()
        if deleted_photo is None:
            print("Photo deleted successfully")
        else:
            print("Photo deletion failed")
    else:
        print("No photo found in the database")


################################################################################
File: ./jest.config.js
module.exports = {
  testTimeout: 30000, // 30 seconds
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
};


################################################################################
File: ./device_config_backup2.json
[
    {
        "MAC Address": "NA",
        "Host Name": "DPF-Eco-Principal-00001",
        "Serial Number": "00001",
        "Name": "My New Device (S/N: 00001)",
        "Type": "Principal",
        "IP Address": "192.168.1.21",
        "Connected": true,
        "Update Frequency": 15,
        "Randomize": true,
        "Photo List": []
    },
    {
        "MAC Address": "b8:27:eb:7e:ce:7b",
        "Host Name": "DPF-Eco-Agent-00002",
        "Serial Number": "00002",
        "Name": "My New Device (S/N: 00002)",
        "Type": "Agent",
        "IP Address": "192.168.1.26",
        "Connected": true,
        "Update Frequency": 15,
        "Randomize": true,
        "Photo List": []
    }
]


################################################################################
File: ./problem.py
import os
import subprocess

def get_files_by_extension(root_dir, extensions, excluded_files):
    """Recursively get all files in root_dir with the specified extensions, excluding certain files."""
    for dirpath, _, filenames in os.walk(root_dir):
        for filename in filenames:
            if filename.split('.')[-1] in extensions and filename not in excluded_files:
                yield os.path.join(dirpath, filename)

def read_file_content(file_path):
    """Read the content of a file."""
    with open(file_path, 'r', encoding='utf-8', errors='ignore') as file:
        return file.read()

def count_lines(file_path):
    """Count the number of lines in a file."""
    with open(file_path, 'r', encoding='utf-8', errors='ignore') as file:
        return sum(1 for _ in file)

def get_tree_output():
    """Get the output of the 'tree' command."""
    result = subprocess.run(['tree'], capture_output=True, text=True)
    return result.stdout

def main():
    extensions = ['py', 'json', 'js', 'html', 'css']
    excluded_files = ['package-lock.json']
    root_dir = '.'
    
    separator = '\n' + '#' * 80 + '\n'
    all_code = ''
    file_lines = []
    
    # Get tree output
    tree_output = get_tree_output()
    
    for file_path in get_files_by_extension(root_dir, extensions, excluded_files):
        file_content = read_file_content(file_path)
        file_info = f"File: {file_path}\n"
        all_code += separator + file_info + file_content + '\n'
        line_count = count_lines(file_path)
        file_lines.append((file_path, line_count))
    
    # Sort files by the number of lines
    file_lines.sort(key=lambda x: x[1], reverse=True)
    
    # Create the lines info text
    lines_info = "Files sorted by the number of lines:\n"
    for file_path, line_count in file_lines:
        lines_info += f"{file_path}: {line_count} lines\n"
    
    with open('output.txt', 'w', encoding='utf-8') as output_file:
        output_file.write(tree_output + '\n')
        output_file.write(lines_info + '\n')
        output_file.write(all_code)
    
    print("Directory structure, file line counts, and code from specified files have been written to output.txt")

if __name__ == "__main__":
    main()


################################################################################
File: ./photo_config.json
[
    {
        "Unique ID": "mpBSMKE4D8.jpg",
        "Name": "mpBSMKE4D8.jpg",
        "Rotation": 0,
        "Scaling": 60,
        "Window": {
            "x": 106,
            "y": 132
        }
    },
    {
        "Unique ID": "Pkroj66an4.jpg",
        "Name": "Pkroj66an4.jpg",
        "Rotation": 0,
        "Scaling": 75,
        "Window": {
            "x": 58,
            "y": 482
        }
    },
    {
        "Unique ID": "fS62c2xUWT.jpg",
        "Name": "fS62c2xUWT.jpg",
        "Rotation": 0,
        "Scaling": 75,
        "Window": {
            "x": 22,
            "y": 494
        }
    },
    {
        "Unique ID": "FvcNHSlZ7N.jpg",
        "Name": "FvcNHSlZ7N.jpg",
        "Rotation": 0,
        "Scaling": 75,
        "Window": {
            "x": 62,
            "y": 200
        }
    },
    {
        "Unique ID": "VMNx4GiCdR.jpg",
        "Name": "VMNx4GiCdR.jpg",
        "Rotation": 0,
        "Scaling": 75,
        "Window": {
            "x": 60,
            "y": 478
        }
    },
    {
        "Unique ID": "iCX17AHy6U.jpg",
        "Name": "iCX17AHy6U.jpg",
        "Rotation": 0,
        "Scaling": 75,
        "Window": {
            "x": 16,
            "y": 344
        }
    },
    {
        "Unique ID": "JFXmfbO2Us.jpg",
        "Name": "JFXmfbO2Us.jpg",
        "Rotation": 0,
        "Scaling": 75,
        "Window": {
            "x": 10,
            "y": 122
        }
    },
    {
        "Unique ID": "pVjzOkvFUI.jpg",
        "Name": "pVjzOkvFUI.jpg",
        "Rotation": 0,
        "Scaling": 40,
        "Window": {
            "x": 156,
            "y": 484
        }
    },
    {
        "Unique ID": "kIq6e2IxYh.jpg",
        "Name": "kIq6e2IxYh.jpg",
        "Rotation": 0,
        "Scaling": 40,
        "Window": {
            "x": 42,
            "y": 312
        }
    }
]

################################################################################
File: ./package.json
{
  "devDependencies": {
    "jest": "^29.7.0",
    "puppeteer": "^22.10.0"
  }
}


################################################################################
File: ./test_config.py
# test_config.py
import os
basedir = os.path.abspath(os.path.dirname(__file__))

class TestConfig:
    TESTING = True
    SQLALCHEMY_DATABASE_URI = 'sqlite:///:memory:'
    SQLALCHEMY_TRACK_MODIFICATIONS = False


################################################################################
File: ./app.py
from flask import Flask, render_template, jsonify, request, redirect, url_for, send_from_directory
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from werkzeug.utils import secure_filename
import os
import socket
import netifaces as ni
import logging

logging.basicConfig(level=logging.DEBUG)

# Initialize the Flask app
app = Flask(__name__, static_folder='static', static_url_path='/static')

# Configuration for file uploads
UPLOAD_FOLDER = os.path.join(app.root_path, 'uploads')
ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER

app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///photos.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

db = SQLAlchemy(app)
migrate = Migrate(app, db)

# Define the Photo model
class Photo(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    photo_name = db.Column(db.String(100), nullable=False)
    path = db.Column(db.String(200), nullable=False)
    rotation = db.Column(db.Integer, default=0)
    scaling = db.Column(db.Integer, default=100)
    window_x = db.Column(db.Integer, default=0)
    window_y = db.Column(db.Integer, default=0)
    split_screen_x = db.Column(db.Integer, default=0)
    split_screen_y = db.Column(db.Integer, default=0)
    split_screen_width = db.Column(db.Integer, default=100)
    split_screen_height = db.Column(db.Integer, default=100)

# Define the Device model
class Device(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    device_name = db.Column(db.String(100), nullable=False)
    device_type = db.Column(db.String(50), nullable=False)
    status = db.Column(db.String(50), nullable=False)
    ip_address = db.Column(db.String(50), nullable=False)
    photo_update_frequency = db.Column(db.Integer, default=0)
    random_order = db.Column(db.Boolean, default=False)

# Define the PhotoDevice model
class PhotoDevice(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    photo_id = db.Column(db.Integer, db.ForeignKey('photo.id'), nullable=False)
    device_id = db.Column(db.Integer, db.ForeignKey('device.id'), nullable=False)

# Function to get IP address
def get_ip_address():
    hostname = socket.gethostname()
    fqdn = socket.getfqdn()

    try:
        interfaces = ni.interfaces()
        for interface in interfaces:
            if ni.AF_INET in ni.ifaddresses(interface):
                ip_address = ni.ifaddresses(interface)[ni.AF_INET][0]['addr']
                if ip_address != '127.0.0.1':
                    break
    except Exception as e:
        print(f"Error getting IP address: {e}")
        ip_address = None

    return ip_address, fqdn

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

# Route to render the main page
@app.route('/')
def index():
    return render_template('index.html')

# Route to render the device editor page
@app.route('/device-editor')
def device_editor():
    return render_template('device_editor.html')

# Route to render the photo editor page
@app.route('/photo-editor')
def photo_editor():
    return render_template('photo_editor.html')

@app.route('/api/get_device/<device_id>', methods=['GET'])
def get_device(device_id):
    device = Device.query.get(device_id)
    if device:
        attached_photos = PhotoDevice.query.filter_by(device_id=device_id).all()
        photos = [Photo.query.get(photo_device.photo_id) for photo_device in attached_photos]
        photos_data = [
            {
                "photo_id": photo.id,
                "photo_name": photo.photo_name,
                "path": url_for('uploaded_file', filename=os.path.basename(photo.path))
            } for photo in photos
        ]
        device_data = {
            "device_id": device.id,
            "device_name": device.device_name,
            "photo_update_frequency": device.photo_update_frequency,
            "random_order": device.random_order,
            "photos": photos_data
        }
        return jsonify(device_data)
    else:
        return jsonify({"error": "Device not found"}), 404


# API endpoint to find discoverable Bluetooth devices
@app.route('/api/find_discoverable_bluetooth_devices', methods=['GET'])
def find_discoverable_bluetooth_devices():
    global discovered_devices
    discovered_devices = {
        "00:11:22:33:44:55": {"device_name": "Device1", "device_type": "Agent", "status": "Online", "ip_address": "192.168.1.2"},
        "00:11:22:33:44:56": {"device_name": "Device2", "device_type": "Agent", "status": "Offline", "ip_address": "192.168.1.3"}
    }
    return jsonify(discovered_devices)

# API endpoint to invite devices to the network
@app.route('/api/invite_to_network', methods=['POST'])
def invite_to_network():
    global discovered_devices
    data = request.json
    print(f"Inviting devices: {data}")

    for mac in data:
        device = discovered_devices.get(mac)
        if device:
            print(f"Adding device: {device}")
            new_device = Device(
                device_name=device['device_name'],
                device_type=device['device_type'],
                status=device['status'],
                ip_address=device['ip_address']
            )
            db.session.add(new_device)
    
    db.session.commit()
    return jsonify({"success": True})

# API endpoint to enumerate WiFi devices
@app.route('/api/enumerate_wifi_devices', methods=['GET'])
def enumerate_wifi_devices():
    devices = Device.query.all()
    devices_dict = {
        device.id: {
            "device_name": device.device_name,
            "device_type": device.device_type,
            "status": device.status,
            "ip_address": device.ip_address
        }
        for device in devices
    }
    return jsonify(devices_dict)

# API endpoint to get all photos
# ./app.py

@app.route('/api/get_all_photos', methods=['GET'])
def get_all_photos():
    photos = Photo.query.all()
    photos_dict = {photo.id: {"photo_name": photo.photo_name, "path": url_for('uploaded_file', filename=os.path.basename(photo.path))} for photo in photos}
    return jsonify(photos_dict)

@app.route('/api/get_all_devices', methods=['GET'])
def get_all_devices():
    devices = Device.query.all()
    devices_dict = {device.id: {"device_name": device.device_name, "device_type": device.device_type, "status": device.status} for device in devices}
    return jsonify(devices_dict)


@app.route('/api/get_photo/<photo_id>', methods=['GET'])
def get_photo(photo_id):
    photo = Photo.query.get(photo_id)
    if photo:
        photo_data = {
            "photo_id": photo.id,
            "photo_name": photo.photo_name,
            "path": url_for('uploaded_file', filename=os.path.basename(photo.path)),
            "rotation": photo.rotation,
            "scaling": photo.scaling,
            "window": {"x": photo.window_x, "y": photo.window_y},
            "split_screen": {
                "x": photo.split_screen_x,
                "y": photo.split_screen_y,
                "width": photo.split_screen_width,
                "height": photo.split_screen_height
            }
        }
        logging.debug(f"Photo data: {photo_data}")
        return jsonify(photo_data)
    else:
        return jsonify({"error": "Photo not found"}), 404

@app.route('/api/upload_photo', methods=['POST'])
def upload_photo():
    logging.debug('Upload photo endpoint called')
    if 'file' not in request.files:
        logging.error("No file part in the request")
        return jsonify({"error": "No file part"}), 400
    file = request.files['file']
    if file.filename == '':
        logging.error("No selected file")
        return jsonify({"error": "No selected file"}), 400
    if file and allowed_file(file.filename):
        filename = secure_filename(file.filename)
        filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
        file.save(filepath)
        logging.debug(f'File saved to {filepath}')
        new_photo = Photo(photo_name=filename, path=filepath)
        db.session.add(new_photo)
        db.session.commit()
        logging.debug(f'New photo added to database with id {new_photo.id}')
        return jsonify({"success": True, "photo_id": new_photo.id}), 201
    logging.error("File type not allowed")
    return jsonify({"error": "File type not allowed"}), 400

@app.route('/uploads/<filename>')
def uploaded_file(filename):
    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)

# API endpoint to save device configuration
@app.route('/api/save_device_config', methods=['POST'])
def save_device_config():
    data = request.json
    print(f"Saving device config: {data}")
    device = Device.query.filter_by(device_name=data['device_name']).first()
    if device:
        device.photo_update_frequency = data['photo_update_frequency']
        device.random_order = data['random_order']
        db.session.commit()
        return jsonify({"success": True})
    else:
        return jsonify({"error": "Device not found"}), 404

@app.route('/api/save_photo_config', methods=['POST'])
def save_photo_config():
    data = request.json
    photo = Photo.query.get(data['photo_id'])
    if photo:
        photo.rotation = data['rotation']
        photo.scaling = data['scaling']
        photo.window_x = data['window']['x']
        photo.window_y = data['window']['y']
        photo.split_screen_x = data['split_screen']['x']
        photo.split_screen_y = data['split_screen']['y']
        photo.split_screen_width = data['split_screen']['width']
        photo.split_screen_height = data['split_screen']['height']
        db.session.commit()
        return jsonify({"success": True})
    return jsonify({"error": "Photo not found"}), 404

# API endpoint to add photos to devices
@app.route('/api/add_photos_to_devices', methods=['POST'])
def add_photos_to_devices():
    data = request.json
    print(f"Adding photos to devices: {data}")
    photo_ids = data.get('photo_ids', [])
    device_ids = data.get('device_ids', [])
    for photo_id in photo_ids:
        for device_id in device_ids:
            new_photo_device = PhotoDevice(photo_id=photo_id, device_id=device_id)
            db.session.add(new_photo_device)
    db.session.commit()
    return jsonify({"success": True})

# API endpoint to move a photo
@app.route('/api/move_photo/<photo_id>', methods=['POST'])
def move_photo(photo_id):
    direction = request.json.get('direction')
    print(f"Moving photo {photo_id} {direction}")
    return jsonify({"success": True})

# API endpoint to remove a photo
@app.route('/api/remove_photo/<photo_id>', methods=['DELETE'])
def remove_photo(photo_id):
    print(f"Removing photo {photo_id}")
    return jsonify({"success": True})

# API endpoint to get the IP address
@app.route('/api/get_ip_address', methods=['GET'])
def get_ip():
    ip_address, fqdn = get_ip_address()
    return jsonify({'ip_address': ip_address, 'fqdn': fqdn})

# Function to map URL to IP
def map_url_to_ip(ip_address):
    url = f"http://{ip_address}:5000"
    try:
        with open('/etc/hosts', 'a') as f:
            f.write(f"{ip_address}\tframecast.local\n")
        print(f"Mapped {url} to framecast.local")
    except Exception as e:
        print(f"Error mapping URL to IP: {e}")

# Route to reset the state (useful for tests)
@app.route('/reset', methods=['GET'])
def reset_state():
    # Clear all photos
    db.session.query(Photo).delete()
    # Add initial photos
    initial_photos = [
        Photo(photo_name='Photo1', path='path/to/photo1.jpg'),
        Photo(photo_name='Photo2', path='path/to/photo2.jpg')
    ]
    db.session.bulk_save_objects(initial_photos)
    db.session.commit()
    return jsonify({"success": True})

# API endpoint to map URL
@app.route('/api/map_url', methods=['GET'])
def map_url():
    ip_address, _ = get_ip_address()
    map_url_to_ip(ip_address)
    return jsonify({'success': True})

# Main function to run the application
if __name__ == '__main__':
    if not os.path.exists(app.config['UPLOAD_FOLDER']):
        os.makedirs(app.config['UPLOAD_FOLDER'])
    with app.app_context():
        db.create_all()
    app.run(debug=True, host='0.0.0.0')


################################################################################
File: ./photo_config_backup.json
[
    {
        "Scaling": 50, 
        "Unique ID": "1", 
        "Rotation": 0, 
        "Name": "photo_1.jpg",
        "Window": {
            "y": 100, 
            "x": 0
        }
    },
    {
        "Scaling": 75, 
        "Unique ID": "2", 
        "Rotation": 0, 
        "Name": "photo_2.jpg",
        "Window": {
            "y": 400, 
            "x": 50
        }
    },
    {
        "Scaling": 75, 
        "Unique ID": "3", 
        "Rotation": 0, 
        "Name": "photo_3.jpg",
        "Window": {
            "y": 450, 
            "x": 50
        }
    },
    {
        "Scaling": 75, 
        "Unique ID": "4", 
        "Rotation": 0, 
        "Name": "photo_4.jpg",
        "Window": {
            "y": 200, 
            "x": 55
        }
    },
    {
        "Scaling": 75, 
        "Unique ID": "5", 
        "Rotation": 0, 
        "Name": "photo_5.jpg",
        "Window": {
            "y": 456, 
            "x": 55
        }
    },
    {
        "Scaling": 75, 
        "Unique ID": "6", 
        "Rotation": 0, 
        "Name": "photo_6.jpg",
        "Window": {
            "y": 350, 
            "x": 55
        }
    },
    {
        "Scaling": 75, 
        "Unique ID": "7", 
        "Rotation": 0, 
        "Name": "photo_7.jpg",
        "Window": {
            "y": 150, 
            "x": 55
        }
    },
    {
        "Scaling": 75, 
        "Unique ID": "8", 
        "Rotation": 0, 
        "Name": "photo_8.jpg",
        "Window": {
            "y": 350, 
            "x": 55
        }
    }
]


################################################################################
File: ./test_app.py
# test_app.py
import unittest
from app import app, db, Photo
from test_config import TestConfig

class FlaskTestCase(unittest.TestCase):
    def setUp(self):
        app.config.from_object(TestConfig)
        self.app = app.test_client()
        self.app.testing = True
        with app.app_context():
            db.create_all()

    def tearDown(self):
        with app.app_context():
            db.session.remove()
            db.drop_all()

    def test_save_photo_config(self):
        # Add a test photo
        with app.app_context():
            new_photo = Photo(photo_name="Test Photo", path="path/to/test_photo.jpg")
            db.session.add(new_photo)
            db.session.commit()
            photo_id = new_photo.id

        # Test saving photo config
        photo_config = {
            "photo_id": photo_id,
            "rotation": 90,
            "scaling": 50,
            "window": {"x": 10, "y": 20},
            "split_screen": {"x": 5, "y": 5, "width": 50, "height": 50}
        }
        response = self.app.post('/api/save_photo_config', json=photo_config)
        self.assertEqual(response.status_code, 200)
        self.assertTrue(response.json['success'])

        # Verify the photo config was saved
        with app.app_context():
            photo = Photo.query.get(photo_id)
            self.assertEqual(photo.rotation, 90)
            self.assertEqual(photo.scaling, 50)
            self.assertEqual(photo.window_x, 10)
            self.assertEqual(photo.window_y, 20)
            self.assertEqual(photo.split_screen_x, 5)
            self.assertEqual(photo.split_screen_y, 5)
            self.assertEqual(photo.split_screen_width, 50)
            self.assertEqual(photo.split_screen_height, 50)

if __name__ == '__main__':
    unittest.main()


################################################################################
File: ./digital_photo_frame_config.json
[
    {
        "Photo List": [
            {
                "Scaling": 50, 
                "Unique ID": "1", 
                "Rotation": 0, 
                "Name": "photo_1.jpg",
                "Window": {
                    "y": 100, 
                    "x": 0
                }
            },
            {
                "Scaling": 75, 
                "Unique ID": "1", 
                "Rotation": 0, 
                "Name": "photo_2.jpg",
                "Window": {
                    "y": 400, 
                    "x": 50
                }
            },
            {
                "Scaling": 75, 
                "Unique ID": "1", 
                "Rotation": 0, 
                "Name": "photo_3.jpg",
                "Window": {
                    "y": 450, 
                    "x": 50
                }
            },
            {
                "Scaling": 75, 
                "Unique ID": "1", 
                "Rotation": 0, 
                "Name": "photo_4.jpg",
                "Window": {
                    "y": 200, 
                    "x": 55
                }
            }
        ], 
        "IP Address": "172.20.10.7", 
        "Serial Number": "abc", 
        "Connected": false, 
        "Name": "Device 1", 
        "MAC Address": "ABC", 
        "Randomize": true, 
        "Update Frequency": 3, 
        "Type": "Principal", 
        "Host Name": "Frame1"
    },
    {
        "Photo List": [
            {
                "Scaling": 75, 
                "Unique ID": "1", 
                "Rotation": 0, 
                "Name": "photo_5.jpg",
                "Window": {
                    "y": 456, 
                    "x": 55
                }
            },
            {
                "Scaling": 75, 
                "Unique ID": "1", 
                "Rotation": 0, 
                "Name": "photo_6.jpg",
                "Window": {
                    "y": 350, 
                    "x": 55
                }
            },
            {
                "Scaling": 75, 
                "Unique ID": "1", 
                "Rotation": 0, 
                "Name": "photo_7.jpg",
                "Window": {
                    "y": 150, 
                    "x": 55
                }
            },
            {
                "Scaling": 75, 
                "Unique ID": "1", 
                "Rotation": 0, 
                "Name": "photo_8.jpg",
                "Window": {
                    "y": 350, 
                    "x": 55
                }
            }
        ], 
        "IP Address": "172.20.10.11", 
        "Serial Number": "abc", 
        "Connected": false, 
        "Name": "Device 1", 
        "MAC Address": "ABC", 
        "Randomize": true, 
        "Update Frequency": 3, 
        "Type": "Agent", 
        "Host Name": "Frame1"
    }
]


################################################################################
File: ./device_config.json
[
    {
        "MAC Address": "NA",
        "Host Name": "FrameCast-v0-Principal-00001",
        "Serial Number": "00001",
        "Name": "My Frame 1",
        "Type": "Principal",
        "IP Address": "192.168.1.46",
        "Connected": false,
        "Update Frequency": "5",
        "Randomize": false,
        "Photo List": [
            "mpBSMKE4D8.jpg",
            "Pkroj66an4.jpg",
            "fS62c2xUWT.jpg"
        ]
    },
    {
        "MAC Address": "2c:cf:67:21:6e:5a",
        "Host Name": "FrameCast-v0-Agent-00002",
        "Serial Number": "00002",
        "Name": "My Frame 2",
        "Type": "Agent",
        "IP Address": "192.168.1.26",
        "Connected": false,
        "Update Frequency": "5",
        "Randomize": false,
        "Photo List": [
            "FvcNHSlZ7N.jpg",
            "VMNx4GiCdR.jpg",
            "iCX17AHy6U.jpg"
        ]
    },
    {
        "MAC Address": "b8:27:eb:37:72:b4",
        "Host Name": "FrameCast-v0-Agent-00003",
        "Serial Number": "00003",
        "Name": "My Frame 3",
        "Type": "Agent",
        "IP Address": "192.168.1.35",
        "Connected": false,
        "Update Frequency": "5",
        "Randomize": false,
        "Photo List": [
            "JFXmfbO2Us.jpg",
            "pVjzOkvFUI.jpg",
            "kIq6e2IxYh.jpg"
        ]
    }
]

################################################################################
File: ./principal/principal_manager.py
import threading
import time
import requests
import socket

def get_ip_address():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        # Unreachable ID address to force socket open
        s.connect(('10.254.254.254',1))
        IP = s.getsockname()[0]
    except Exception:
        IP = '127.0.0.1'
    finally:
        s.close()
    
    return IP

def check_dns_map(ip):
	
	ip_mapped = False
	config_line = f"address=/framecast.local/{ip}"
	with open("/etc/dnsmasq.conf","r") as file:
		lines = file.readlines()
		for line in lines:
			if config_line in line:
				ip_mapped = True
	
	return ip_mapped
    
def run_principal_manager():
	
	while True:
		
		current_ip = get_ip_address()
		print(current_ip)
		if not check_dns_map(current_ip):
			url = f"http://{current_ip}:5000/api/update_dns"
			try:
				response = requests.get(url)
				print(response)
			except requests.exceptions.RequestException as e:
				print("Error making API call:", e)
		
		time.sleep(5)	
			
if __name__ == '__main__':
	run_principal_manager()		
			
		
    
		
		
		


################################################################################
File: ./principal/photo_formatter(1).py
#import tkinter as tk
import os
import sys
from PIL import Image, ImageTk, ExifTags

current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
import_dir = os.path.join(parent_dir,'principal')
sys.path.append(import_dir)

from framecast_classes import DigitalPhoto, PhotoViewWindow

import os
import io
     
def format_for_display(digital_photo, src_file_path, dest_file_path):

    photo = Image.open(src_file_path)
    photo = suppress_auto_rotate(photo)
    
    scaling = digital_photo.scaling
    if scaling != 100:
        w, h = photo.size
        w, h = (int)(w*scaling/100), (int)(h*scaling/100)
        photo = photo.resize((w,h),resample=Image.NEAREST)
    
    left = digital_photo.window.x
    top = digital_photo.window.y
    right = left+1024
    bottom = top+600
    
    photo = photo.crop((left,top,right,bottom))
    photo.save(dest_file_path)
    
def suppress_auto_rotate(photo):
    
    try:
        for orientation in ExifTags.TAGS.keys():
            if ExifTags.TAGS[orientation] == 'Orientation':
                break
        exif = photo._getexif()
        if exif is not None:
            orientation = exif.get(orientation,1)
            if orientation == 3:
                photo = photo.rotate(180, expand=True)
            elif orientation == 6:
                photo = photo.rotate(270, expand=True)
            elif orientation == 8:
                photo = photo.rotate(90, expand=True)
    except (AttributeError, KeyError, IndexError):
        pass
    
    return photo
        
def format_photo_for_edit_window(filepath, scaleValue):
    
    actualScaleValue = (int)(scaleValue)/100 * 0.5
    
    photo = Image.open(filepath)
    photo = suppress_auto_rotate(photo)
    photo = photo.resize(((int)(photo.width * actualScaleValue),(int)(photo.height * actualScaleValue)), Image.ANTIALIAS)

    photo_io = io.BytesIO()
    photo.save(photo_io, 'JPEG')
    photo_io.seek(0)
    
    return photo_io

def format_photo_for_preview(filepath):
    
    photo = Image.open(filepath)
    photo = suppress_auto_rotate(photo)
    
    w = photo.width
    h = photo.height
    
    scaleValue = 1;
    
    if w >= h:
        scaleValue = w/300
    else:
        scaleValue = h/300
    
    print(photo.width)
    print(photo.height)
      
    photo = photo.resize(((int)(photo.width / scaleValue),(int)(photo.height / scaleValue)), Image.ANTIALIAS)
    print(photo.width)
    print(photo.height)
    photo_io = io.BytesIO()
    photo.save(photo_io, 'JPEG')
    photo_io.seek(0)
    
    return photo_io
        
        
        



################################################################################
File: ./principal/jsonDeviceConfigTest.json
[
    {
        "MAC Address": "ABC",
        "Host Name": "Frame1",
        "Serial Number": "abc",
        "Name": "Device 1",
        "Type": "Unassigned",
        "IP Address": "0.0.0.0",
        "Connected": false,
        "Update Frequency": 15,
        "Randomize": true,
        "Photo List": ["Photo1.jpg","Photo2.jpg","Photo3.jpg"]
    },
    {
        "MAC Address": "DEF",
        "Host Name": "Frame2",
        "Serial Number": "abc",
        "Name": "Device 1",
        "Type": "Unassigned",
        "IP Address": "0.0.0.0",
        "Connected": false,
        "Update Frequency": 15,
        "Randomize": true,
        "Photo List": ["Photo4.jpg","Photo5.jpg","Photo6.jpg"]
    }
]


################################################################################
File: ./principal/framecast_classes.py
from enum import Enum
import json
import os
import sys
import requests

current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
device_config_path = os.path.join(parent_dir,'device_config.json')
photo_config_path = os.path.join(parent_dir,'photo_config.json')
photo_library_path = os.path.join(parent_dir,'photo_library')

import_dir = os.path.join(parent_dir,'principal')
sys.path.append(import_dir)

from scp_connection_manager import PersistentSCPConnection, is_host_alive, send_file_to_host

# New DPF objects are UNASSIGNED until given a type based on the discovered device name
class DeviceType(Enum):
    UNASSIGNED = "Unassigned"
    PRINCIPAL = "Principal"
    AGENT = "Agent"

# Core definitions for the DPF class including connection and file transfer functions.
class DigitalPhotoFrame:
    def __init__(self, mac_address, host_name, serial_number, device_type):
        self.mac_address = mac_address
        self.host_name = host_name
        self.serial_number = serial_number
        self.device_type = device_type
        self.name = f"My New Device (S/N: {serial_number})"
        self.ip_address = "0.0.0.0"
        self.connected = False
        self.photo_list = []
        self.update_freq = 15
        self.randomize = True
        
        self.last_photo_update = 0
        self.photo_order = 0
        self.scp_connection = None
    
    # Initiates a GET request to an Agent's HTTP server heartbeat route to establish the Agent is running and not just present on the network.
    def test_connection(self):
        
        return is_host_alive(self.ip_address)
    
    # Sets up the persistent SCP connection. Since the SCP connection takes several seconds, the connection is maintained.
    def connect_to_frame(self):
    
        # The user and password must configured to be the values below on each Agent device.
        print(f"Connection parameters in connect_to_frame:\n{self.ip_address} rpi0w raspberry")
        self.scp_connection = PersistentSCPConnection(self.ip_address,"rpi0w","raspberry")
        return self.scp_connection.connect()
    
    # Sends photo to an Agent if an SCP connection was set up.
    def send_photo_to_frame(self, photo_filepath):
        
        current_status = self.connected
        if self.test_connection():
            if not self.connected or self.scp_connection is None:
                self.connected = self.connect_to_frame()
            if self.connected:
                self.connected = send_file_to_host(self.scp_connection, photo_filepath)
        else:
            self.connected = False
            
        if current_status != self.connected:
            data = {
                'Host Name': self.host_name,
                'Connected': self.connected
            }
            update_device_connection_status(data)
            #response = requests.post('http://localhost:5000/api/update_connection_status',json=data)
            #print('POST response:', response.json())
        
        return self.connected

    
    def set_mac_address(self, mac_address):
        self.mac_address = mac_address
    
    def set_serial_number(self, serial_number):
        self.serial_number = serial_number
        
    def set_name(self, name):
        self.name = name
    
    def set_type(self, device_type):
        self.device_type = device_type
        
    def set_ip_address(self, ip_address):
        self.ip_address = ip_address
    
    def set_connected(self, connected):
        self.connected = connected
    
    def set_photo_list(self, photo_list):
        self.photo_list = photo_list
    
    def set_update_frequency(self, update_freq):
        self.update_freq = update_freq
    
    def set_randomize(self, randomize):
        self.randomize = randomize
    
    # This is used to construct the JSON config string.
    def get_object_dict(self):
        return {
            'MAC Address': self.mac_address,
            'Host Name': self.host_name,
            'Serial Number': self.serial_number,
            'Name': self.name,
            'Type': self.device_type.value,
            'IP Address': self.ip_address,
            'Connected': self.connected,
            'Update Frequency': self.update_freq,
            'Randomize': self.randomize,
            'Photo List': self.photo_list
        }
    
    # This is used to configure a DPF object based on the JSON config.
    @classmethod
    def set_object_from_dict(cls, data):
        
        #photo_list = [DigitalPhoto.set_object_from_dict(photo) for photo in data['Photo List']]
        device_type = DeviceType(data['Type'])
        
        frame = cls(
            mac_address=data['MAC Address'],
            host_name=data['Host Name'],
            serial_number = data['Serial Number'],
            device_type = device_type
        )
    
        #frame.set_serial_number(data['Serial Number'])
        frame.set_name(data['Name'])
        #frame.set_type(device_type)
        frame.set_ip_address(data['IP Address'])
        frame.set_connected(data['Connected'])
        frame.set_update_frequency(data['Update Frequency'])
        frame.set_randomize(data['Randomize'])
        frame.set_photo_list(data['Photo List'])
        
        return frame
      
    # This is only used for simulating a DPF collection by manually instantiating DP objects.
    def add_photo(self, photo):
        self.photo_list.append(photo)
        
# Defines the portion of the unedited photo to be displayed on the LCD.
class PhotoViewWindow:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        
    def set_x(self, x):
        this.x=x
    
    def set_y(self, y):
        this.x=x
        
    @classmethod
    def set_object_from_dict(cls, data):
        
        window = cls(x=data['x'],y=data['y'])
        
        return window
    
    def get_object_dict(self):
        return {
            'x': self.x,
            'y': self.y,
        }
        
class DigitalPhoto:
    def __init__(self, unique_id):
        self.unique_id = unique_id
        self.name = unique_id
        self.rotation = 0
        self.scaling = 100
        self.window = PhotoViewWindow(0,0)
        
    def set_name(self, name):
        self.name = name
    
    def get_name(self):
        return self.name
    
    def set_rotation(self, rotation):
        self.rotation = rotation
    
    def set_scaling(self, scaling):
        self.scaling = scaling
    
    def get_scaling(self):
        return self.scaling
    
    def set_window(self, window):
        self.window = PhotoViewWindow.set_object_from_dict(window)
        
    def get_object_dict(self):
        
        return {
            'Unique ID': self.unique_id,
            'Name': self.name,
            'Rotation': self.rotation,
            'Scaling': self.scaling,
            'Window': self.window.get_object_dict()
        }
    
    @classmethod
    def set_object_from_dict(cls, data):
        
        photo = cls(unique_id=data['Unique ID'])
        
        photo.set_name(data['Name'])
        photo.set_rotation(data['Rotation'])
        photo.set_scaling(data['Scaling'])
        photo.set_window(data['Window'])
        
        return photo

digital_photo_frame_collection = []
digital_photo_collection = []

'''def write_test(photo_config_file, device_config_file):
    
    frame1 = DigitalPhotoFrame("ABC", "Frame1")
    frame2 = DigitalPhotoFrame("DEF", "Frame2")
    photo1 = DigitalPhoto("1")
    photo2 = DigitalPhoto("2")
    photo3 = DigitalPhoto("3")
    
    digital_photo_frame_collection.append(frame1)
    digital_photo_frame_collection.append(frame2)
    digital_photo_collection.append(photo1)
    digital_photo_collection.append(photo2)
    digital_photo_collection.append(photo3)
     
    json_device_dict = [frame.get_object_dict() for frame in digital_photo_frame_collection]
    json_photo_dict = [photo.get_object_dict() for photo in digital_photo_collection]
    json_device_string = json.dumps(json_device_dict, indent=4)
    json_photo_string = json.dumps(json_photo_dict, indent=4)
        
    print(json_device_string)
    print(json_photo_string)
    
    with open(photo_config_file, 'w') as file:
        file.write(json_photo_string)
    
    with open(device_config_file, 'w') as file:
        file.write(json_device_string)'''

def save_device_collection():
    
    json_device_string = json_parse_device_collection()
    
    with open(device_config_path, 'w') as file:
        file.write(json_device_string)
    
def save_photo_collection():
    
    json_photo_string = json_parse_photo_collection()
    
    with open(photo_config_path, 'w') as file:
        file.write(json_photo_string)

'''def get_simulated_collection():
    
    frame1 = DigitalPhotoFrame("ABC", "Frame1")
    frame2 = DigitalPhotoFrame("DEF", "Frame2")
    photo1 = DigitalPhoto("1")
    photo2 = DigitalPhoto("2")
    photo3 = DigitalPhoto("3")
    
    digital_photo_frame_collection.append(frame1)
    digital_photo_frame_collection.append(frame2)
    digital_photo_collection.append(photo1)
    digital_photo_collection.append(photo2)
    digital_photo_collection.append(photo3)
        
    return digital_photo_frame_collection'''

def json_parse_device_collection():
    
    json_dict = [frame.get_object_dict() for frame in digital_photo_frame_collection]
    json_string = json.dumps(json_dict, indent=4)
    
    return json_string
    
def json_parse_photo_collection():
    
    json_dict = [photo.get_object_dict() for photo in digital_photo_collection]
    json_string = json.dumps(json_dict, indent=4)
    
    return json_string
        
'''def read_test(filename):
    
    with open(filename,'r') as file:
        json_string = file.read()
    
    print(json_string)
    
    build_collection_from_json(json_string)
    
    #json_dict = json.loads(json_string)
     
    #digital_photo_frame_collection = [DigitalPhotoFrame.set_object_from_dict(frame) for frame in json_dict]
    
    #json_parse_device_collection(digital_photo_frame_collection)'''

def build_device_collection_from_json(json_string):
    
    json_dict = json.loads(json_string)
    global digital_photo_frame_collection
    digital_photo_frame_collection = [DigitalPhotoFrame.set_object_from_dict(frame) for frame in json_dict]
    #print(json_parse_device_collection())
    
def build_photo_collection_from_json(json_string):
    
    json_dict = json.loads(json_string)
    global digital_photo_collection
    digital_photo_collection = [DigitalPhoto.set_object_from_dict(photo) for photo in json_dict]
    #print(json_parse_photo_collection(digital_photo_collection))
    
def get_device_config(file_path):
    
    if os.path.exists(file_path):
        with open(file_path,'r') as file:
            json_string = file.read()
            print(json_string)
            build_device_collection_from_json(json_string)
            return json_string
    else:
        print("Config file not found")
        return ''

def get_photo_config(file_path):
    
    if os.path.exists(file_path):
        with open(file_path,'r') as file:
            json_string = file.read()
            print(json_string)
            build_photo_collection_from_json(json_string)
            return json_string
    else:
        print("Config file not found")
        return ''
    
def get_device_collection(file_path):
    
    print_module_id()
    
    if os.path.exists(file_path):
        with open(file_path,'r') as file:
            json_string = file.read()
            print(f"JSON string after reading file during get_device_collection\n{json_string}")
    else:
        print("Config file not found")
        return digital_photo_frame_collection
    
    #json_dict = json.loads(json_string)
    
    #return [DigitalPhotoFrame.set_object_from_dict(frame) for frame in json_dict]
    
    build_device_collection_from_json(json_string)
    print(f"DPF collection after reading file during get_device_collection\n{digital_photo_frame_collection}")
    
    return digital_photo_frame_collection

def get_photo_collection(file_path):
    
    if os.path.exists(file_path):
        with open(file_path,'r') as file:
            json_string = file.read()
            print(json_string)
    else:
        print("Config file not found")
        return null
    
    #json_dict = json.loads(json_string)
    
    #return [DigitalPhoto.set_object_from_dict(photo) for photo in json_dict]
    
    build_photo_collection_from_json(json_string)
    
    return digital_photo_collection

# Called whenever web portal has an update
def update_device(data):
    
    index = data["Device Index"]
    print(index)
    print(len(digital_photo_frame_collection))
    
    if index != -1 and len(digital_photo_frame_collection) != 0:
        digital_photo_frame_collection[index].set_name(data["Device Name"])
        digital_photo_frame_collection[index].set_update_frequency(data["Update Frequency"])
        digital_photo_frame_collection[index].set_randomize(data["Randomize"])
        digital_photo_frame_collection[index].set_photo_list(data["Photo List"])
        print (digital_photo_frame_collection[index])
        
        save_device_collection()
    
    return json_parse_device_collection()

def update_photo(data):
    
    index = data["Photo Index"]
    print(index)
    print(len(digital_photo_collection))
    
    if index != -1 and len(digital_photo_collection) != 0:
        digital_photo_collection[index].set_window(data["Window"])
        digital_photo_collection[index].set_scaling((int)(data["Scaling"]))
        print (digital_photo_collection[index])
        
        save_photo_collection()
    
    return json_parse_photo_collection()
    
'''def get_single_photo_config(photo_name):

    for photo in digital_photo_collection:
        print(photo.get_name())
        if photo.get_name() == photo_name:
            return photo
            
    return null'''

def add_new_devices(discovered_devices):
    
    for discovered_device in discovered_devices:
        mac_address = discovered_device["MAC Address"]
        host_name = discovered_device["Host Name"]
        serial_number = discovered_device["Serial Number"]
        device_type = discovered_device["Type"]
        match = False
        for existing_device in digital_photo_frame_collection:
            if existing_device.host_name == host_name:
                match = True
                break
        if not match:
            new_device = DigitalPhotoFrame(
                mac_address,
                host_name,
                serial_number,
                DeviceType.PRINCIPAL if device_type == "Principal" else DeviceType.AGENT
            )
            digital_photo_frame_collection.append(new_device)
    
    save_device_collection()
    
    return json_parse_device_collection()

def remove_devices(devices_to_delete):
    
    print_module_id()
    print(f"Devices_to_delete when entering remove_devices:\n{devices_to_delete}")
    print(f"DPF Collection when entering remove_devices:\n{digital_photo_frame_collection}")
    for device_to_delete in devices_to_delete:
        index = 0
        for existing_device in digital_photo_frame_collection:
            if existing_device.host_name == device_to_delete["Host Name"]:
                print(f"Device to delete:\n{digital_photo_frame_collection[index]}")
                del digital_photo_frame_collection[index]
                break
            index += 1
    
    save_device_collection()
    
    return json_parse_device_collection()

def remove_photos(photos_to_delete):
    
    print_module_id()
    print(f"Devices_to_delete when entering remove_photos:\n{photos_to_delete}")
    print(f"DP Collection when entering remove_photos:\n{digital_photo_collection}")
    for photo_to_delete in photos_to_delete:
        index = 0
        for existing_photo in digital_photo_collection:
            if existing_photo.name == photo_to_delete:
                #print(f"Photo to delete:\n{digital_photo_collection[index]}")
                del digital_photo_collection[index]
                photo_filepath = os.path.join(photo_library_path,photo_to_delete)
                print(f"Photo file path to delete:\n{photo_filepath}")
                if os.path.exists(photo_filepath):
                    os.remove(photo_filepath)
                break
            index += 1
    
    save_photo_collection()
    
    return json_parse_photo_collection()
    
def get_connection_status(networked_devices):
    
    print_module_id()
    
    print(f"DPF Collection when entering get_connection_status:\n{digital_photo_frame_collection}")
    for existing_device in digital_photo_frame_collection:
        match = False
        for networked_device in networked_devices:
            if existing_device.host_name == networked_device["Host Name"]:
                #existing_device.set_connected(True)
                existing_device.set_mac_address(networked_device["MAC Address"])
                existing_device.set_ip_address(networked_device["IP Address"])
                match = True
                break
        #if not match:
            #existing_device.set_connected(False)
    
    save_device_collection()
    
    return json_parse_device_collection()

def update_device_connection_status(data):
    
    print_module_id()
    
    print(f"DPF Collection when entering update_device_connection_status:\n{digital_photo_frame_collection}")
    print_module_id()
    for existing_device in digital_photo_frame_collection:
        if existing_device.host_name == data['Host Name']:
            existing_device.set_connected(data['Connected'])
            break
    
    save_device_collection()
    
    return json_parse_device_collection()

def update_devices_from_mobile(device_config):
    
    device = json.loads(device_config)
    print(device)
    #for device in device_config:
    mac_address = device["MAC Address"]
    host_name = device["Host Name"]
    serial_number = device["Serial Number"]
    device_type = DeviceType.PRINCIPAL if device["Type"] == "Principal" else DeviceType.AGENT
    match = False
    for existing_device in digital_photo_frame_collection:
        if existing_device.host_name == host_name:
            match = True
            existing_device.set_name(device["Name"])
            existing_device.set_ip_address(device["IP Address"])
            existing_device.set_connected(device["Connected"])
            existing_device.set_photo_list(device["Photo List"])
            existing_device.set_update_frequency(device["Update Frequency"])
            existing_device.set_randomize(device["Randomize"])
            break
    if not match:
        new_device = DigitalPhotoFrame(
            mac_address,
            host_name,
            serial_number,
            DeviceType.PRINCIPAL if device_type == "Principal" else DeviceType.AGENT
        )
        new_device.set_name(device["Name"])
        new_device.set_ip_address(device["IP Address"])
        new_device.set_connected(device["Connected"])
        new_device.set_photo_list(device["Photo List"])
        new_device.set_update_frequency(device["Update Frequency"])
        new_device.set_randomize(device["Randomize"])
        digital_photo_frame_collection.append(new_device)
    
    save_device_collection()
    
    return json_parse_device_collection()
    
def update_photos_from_mobile(photo_config):
    
    for photo in photo_config:
        unique_id = photo["Unique ID"]
        match = False
        for existing_photo in digital_photo_collection:
            if existing_photo.unique_id == unique_id:
                match = True
                existing_photo.set_name(photo["Name"])
                existing_photo.set_scaling(photo["Scaling"])
                existing_photo.set_rotation(photo["Rotation"])
                existing_photo.set_window(photo["Window"])
                break
        if not match:
            new_photo = DigitalPhoto(
                unique_id
            )
            existing_photo.set_name(photo["Name"])
            existing_photo.set_scaling(photo["Scaling"])
            existing_photo.set_rotation(photo["Rotation"])
            existing_photo.set_window(photo["Window"])
            digital_photo_collection.append(new_photo)
    
    save_photo_collection()
    
    return json_parse_photo_collection()

def add_new_photos(photo_names):
    
    print("Initial call of add_new_photos function:")
    print(digital_photo_collection)
    
    for photo in photo_names:
        match = False
        for existing_photo in digital_photo_collection:
            if existing_photo.unique_id == photo:
                match = True
                break
        if not match:
            new_photo = DigitalPhoto(photo)
            digital_photo_collection.append(new_photo)
    
    save_photo_collection()
    
    return json_parse_photo_collection()

#For debugging purposes only
def print_module_id():

    print(f"Module memory ID: {id(__import__(__name__))}")

if __name__ == '__main__':
    #write_test('jsonPhotoConfigTest.json','jsonDeviceConfigTest.json')
    read_test('jsonDeviceConfigTest.json')
    
        
    
    


################################################################################
File: ./principal/scp_connection_manager.py
import time
import requests
import paramiko
from scp import SCPClient

class PersistentSCPConnection:
    def __init__(self, hostname,username,password):
        self.hostname = hostname
        self.username = username
        self.password = password
        self.ssh = None
        self.scp = None
        #self.connect()
    
    def connect(self):
        try:
            self.ssh = paramiko.SSHClient()
            self.ssh.load_system_host_keys()
            self.ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            self.ssh.connect(self.hostname, username=self.username, password=self.password, compress=True)
            self.scp = SCPClient(self.ssh.get_transport())
            return True
        except Exception as e:
            print(f"Failed to establish SCP connection: {e}")
            return False
        
    def close(self):
        if self.scp:
            self.scp.close()
        if self.ssh:
            self.ssh.close()
            
    def send_file(self, local_path, remote_path):
        try:
            self.scp.put(local_path, remote_path)
            return True
        except Exception as e:
            print(f"Failed to establish SCP connection: {e}")
            return False

file_path = "current.jpg"
destination_path = "/home/rpi0w/Desktop/FrameCast/controller/displayed_photo/next.jpg"

def is_host_alive(hostname):
    try:
        response = requests.get(f"http://{hostname}:5000/heartbeat", timeout=5)
        if response.status_code == 200:
            print(response.text)
            return True
    except requests.RequestException:
        pass
    return False

def send_file_to_host(scp_connection, photo_filepath):
    
    try:
        scp_connection.send_file(photo_filepath, destination_path)
        print("File sent successfully")
        return True
    except Exception as e:
        print("File not sent successfully")
        return False

if __name__ == '__main__':
        
    if is_host_alive("10.0.0.38"):
        print("Host alive")
    else:
        print("Host not alive")
    
    '''print("Checkpoint 1")
    scp_connection = PersistentSCPConnection("172.20.10.9","rpi0w","raspberry")
    print("Checkpoint 2")
    scp_connection.connect()
    print("Checkpoint 3")
    send_file_to_host(scp_connection,file_path)
    print("Checkpoint 4")
    send_file_to_host(scp_connection,file_path)
    print("Checkpoint 5")
    send_file_to_host(scp_connection,file_path)
    print("Checkpoint 6")'''
    

            
        


################################################################################
File: ./principal/photo_formatter.py
#import tkinter as tk
import os
import sys
from PIL import Image, ImageTk, ExifTags

current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
import_dir = os.path.join(parent_dir,'principal')
sys.path.append(import_dir)

from framecast_classes import DigitalPhoto, PhotoViewWindow

import os
import io
     
def format_for_display(digital_photo, src_file_path, dest_file_path):

    photo = Image.open(src_file_path)
    photo = suppress_auto_rotate(photo)
    
    scaling = digital_photo.scaling
    if scaling != 100:
        w, h = photo.size
        w, h = (int)(w*scaling/100), (int)(h*scaling/100)
        photo = photo.resize((w,h),resample=Image.NEAREST)
    
    left = digital_photo.window.x
    top = digital_photo.window.y
    right = left+1024
    bottom = top+600
    
    photo = photo.crop((left,top,right,bottom))
    photo.save(dest_file_path)
    
def suppress_auto_rotate(photo):
    
    try:
        for orientation in ExifTags.TAGS.keys():
            if ExifTags.TAGS[orientation] == 'Orientation':
                break
        exif = photo._getexif()
        if exif is not None:
            orientation = exif.get(orientation,1)
            if orientation == 3:
                photo = photo.rotate(180, expand=True)
            elif orientation == 6:
                photo = photo.rotate(270, expand=True)
            elif orientation == 8:
                photo = photo.rotate(90, expand=True)
    except (AttributeError, KeyError, IndexError):
        pass
    
    return photo
        
def format_photo_for_edit_window(filepath, scaleValue):
    
    actualScaleValue = (int)(scaleValue)/100 * 0.5
    
    photo = Image.open(filepath)
    photo = suppress_auto_rotate(photo)
    photo = photo.resize(((int)(photo.width * actualScaleValue),(int)(photo.height * actualScaleValue)), Image.Resampling.LANCZOS)

    photo_io = io.BytesIO()
    photo.save(photo_io, 'JPEG')
    photo_io.seek(0)
    
    return photo_io

def format_photo_for_preview(filepath):
    
    photo = Image.open(filepath)
    photo = suppress_auto_rotate(photo)
    
    w = photo.width
    h = photo.height
    
    scaleValue = 1;
    
    if w >= h:
        scaleValue = w/300
    else:
        scaleValue = h/300
    
    print(photo.width)
    print(photo.height)
      
    photo = photo.resize(((int)(photo.width / scaleValue),(int)(photo.height / scaleValue)), Image.Resampling.LANCZOS)
    print(photo.width)
    print(photo.height)
    photo_io = io.BytesIO()
    photo.save(photo_io, 'JPEG')
    photo_io.seek(0)
    
    return photo_io
        
        
        



################################################################################
File: ./principal/agent_manager.py
import time
import os
import shutil
import sys
import random

current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)

if __name__ == '__main__':

	sys.path.insert(0,parent_dir)
	run_agent_manager()	

from principal.framecast_classes import DigitalPhoto, DigitalPhotoFrame, DeviceType, PhotoViewWindow
from principal.framecast_classes import get_device_collection, get_photo_collection
from principal.photo_formatter import format_for_display

device_config_path = os.path.join(parent_dir,'device_config.json')
photo_config_path = os.path.join(parent_dir,'photo_config.json')
photo_library_path = os.path.join(parent_dir, 'photo_library')
displayed_photo_path = os.path.join(parent_dir,'controller','displayed_photo','next.jpg')
formatted_photo_path = os.path.join(parent_dir,'principal','formatted_photos')

def run_agent_manager():

	frame_collection = get_device_collection(device_config_path)			
	photo_collection = get_photo_collection(photo_config_path)
	last_device_config_mod_time = get_file_modification_time(device_config_path)
	last_photo_config_mod_time = get_file_modification_time(photo_config_path)
	
	while True:
		
		#Check config file for updates
		current_device_config_mod_time = get_file_modification_time(device_config_path)
		current_photo_config_mod_time = get_file_modification_time(photo_config_path)
		
		if current_device_config_mod_time != last_device_config_mod_time:
			print("Device Config Updated")
			last_device_config_mod_time = current_device_config_mod_time
			frame_collection = get_device_collection(device_config_path)
			
		if current_photo_config_mod_time != last_photo_config_mod_time:
			print("Photo Config Updated")
			last_photo_config_mod_time = current_photo_config_mod_time
			photo_collection = get_photo_collection(photo_config_path)
			
		
		current_time = time.time()
		
		for frame in frame_collection:	
			
			#print(f"{current_time} {frame.last_photo_update} {frame.update_freq}")
			
			if len(frame.photo_list) > 0 and (current_time - frame.last_photo_update) > int(frame.update_freq):
					
				if len(frame.photo_list) == 1:
					photo_name = frame.photo_list[0]
					frame.photo_order = 0			
				elif frame.randomize:
					photo_name = random.choice(frame.photo_list)	
					photo_index = frame.photo_list.index(photo_name)
					while photo_index == frame.photo_order:
						photo_name = random.choice(frame.photo_list)
						photo_index = frame.photo_list.index(photo_name)
					frame.photo_order = photo_index		
				else:
					photo_name = frame.photo_list[frame.photo_order]
					if frame.photo_order < len(frame.photo_list)-1:
						frame.photo_order = frame.photo_order + 1
					else:
						frame.photo_order = 0
				
				next_photo = next((photo for photo in photo_collection if photo.name == photo_name), None)
				
				original_file_path = os.path.join(photo_library_path,next_photo.name)
				#print(original_file_path)
				formatted_file_path = os.path.join(formatted_photo_path,next_photo.name)
				format_for_display(next_photo, original_file_path, formatted_file_path)			
				
				if frame.device_type == DeviceType.PRINCIPAL:				
					shutil.copy2(formatted_file_path,displayed_photo_path)
					os.remove(formatted_file_path)
				elif frame.device_type == DeviceType.AGENT:									
					if frame.send_photo_to_frame(formatted_file_path):				
						os.remove(formatted_file_path)

				frame.last_photo_update = current_time
				
				#print(next_photo.name)

		#print(current_time)
		time.sleep(1)

def get_file_modification_time(file_path):
	return os.path.getmtime(file_path)
		
	
			


################################################################################
File: ./principal/jsonDeviceConfigTest(1).json
[
    {
        "MAC Address": "ABC",
        "Host Name": "Frame1",
        "Serial Number": "abc",
        "Name": "Device 1",
        "Type": "Unassigned",
        "IP Address": "0.0.0.0",
        "Connected": false,
        "Update Frequency": 15,
        "Randomize": true,
        "Photo List": ["Photo1.jpg","Photo2.jpg","Photo3.jpg"]
    },
    {
        "MAC Address": "DEF",
        "Host Name": "Frame2",
        "Serial Number": "abc",
        "Name": "Device 1",
        "Type": "Unassigned",
        "IP Address": "0.0.0.0",
        "Connected": false,
        "Update Frequency": 15,
        "Randomize": true,
        "Photo List": ["Photo4.jpg","Photo5.jpg","Photo6.jpg"]
    }
]


################################################################################
File: ./principal/agent_manager(1).py
import time
import os
import shutil
import sys

current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)

if __name__ == '__main__':

	sys.path.insert(0,parent_dir)
	run_agent_manager()	

from principal.framecast_classes import DigitalPhoto, DigitalPhotoFrame, DeviceType, PhotoViewWindow
from principal.framecast_classes import get_device_collection, get_photo_collection
from principal.photo_formatter import format_for_display

device_config_path = os.path.join(parent_dir,'device_config.json')
photo_config_path = os.path.join(parent_dir,'photo_config.json')
#print(parent_dir)
photo_library_path = os.path.join(parent_dir, 'photo_library')
#print(photo_library_path)
displayed_photo_path = os.path.join(parent_dir,'controller','displayed_photo','next.jpg')
formatted_photo_path = os.path.join(parent_dir,'principal','formatted_photos')

def run_agent_manager():
		
	frame_collection = get_device_collection(device_config_path)
	photo_collection = get_photo_collection(photo_config_path)
	last_device_config_mod_time = get_file_modification_time(device_config_path)
	last_photo_config_mod_time = get_file_modification_time(photo_config_path)
	
	while True:
		
		#Check config file for updates
		current_device_config_mod_time = get_file_modification_time(device_config_path)
		current_photo_config_mod_time = get_file_modification_time(photo_config_path)
		
		if current_device_config_mod_time != last_device_config_mod_time:
			print("Device Config Updated")
			last_device_config_mod_time = current_device_config_mod_time
			frame_collection = get_device_collection(device_config_path)
			
		if current_photo_config_mod_time != last_photo_config_mod_time:
			print("Photo Config Updated")
			last_photo_config_mod_time = current_photo_config_mod_time
			photo_collection = get_photo_collection(photo_config_path)
			
		
		current_time = time.time()
		for frame in frame_collection:
			if current_time - frame.last_photo_update > frame.update_freq:
				photo_name = frame.photo_list[frame.photo_order]
				
				next_photo = next((photo for photo in photo_collection if photo.name == photo_name), None)
				
				original_file_path = os.path.join(photo_library_path,next_photo.name)
				print(original_file_path)
				formatted_file_path = os.path.join(formatted_photo_path,next_photo.name)
				format_for_display(next_photo, original_file_path, formatted_file_path)			
				
				if frame.device_type == DeviceType.PRINCIPAL:				
					shutil.copy2(formatted_file_path,displayed_photo_path)
					os.remove(formatted_file_path)
				elif frame.device_type == DeviceType.AGENT:	
					print(frame.ip_address)									
					if frame.test_connection():					
						frame.connect_to_frame()
						if frame.send_photo_to_frame(formatted_file_path):
							os.remove(formatted_file_path)
							
				if frame.photo_order < len(frame.photo_list)-1:
					frame.photo_order = frame.photo_order + 1
				else:
					frame.photo_order = 0				
				
				frame.last_photo_update = current_time
				
				#print(next_photo.name)

		#print(current_time)
		time.sleep(1)

def get_file_modification_time(file_path):
	return os.path.getmtime(file_path)
		
	
			


################################################################################
File: ./principal/jsonPhotoConfigTest.json
[
    {
        "Unique ID": "1",
        "Name": "Photo1.jpg",
        "Rotation": 0,
        "Scaling": 100,
        "Window": {
            "x": 0,
            "y": 0
        }
    },
    {
        "Unique ID": "2",
        "Name": "Photo1.jpg",
        "Rotation": 0,
        "Scaling": 100,
        "Window": {
            "x": 0,
            "y": 0
        }
    },
    {
        "Unique ID": "3",
        "Name": "Photo1.jpg",
        "Rotation": 0,
        "Scaling": 100,
        "Window": {
            "x": 0,
            "y": 0
        }
    }
]

################################################################################
File: ./migrations/env.py
import logging
from logging.config import fileConfig

from flask import current_app

from alembic import context

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
fileConfig(config.config_file_name)
logger = logging.getLogger('alembic.env')


def get_engine():
    try:
        # this works with Flask-SQLAlchemy<3 and Alchemical
        return current_app.extensions['migrate'].db.get_engine()
    except (TypeError, AttributeError):
        # this works with Flask-SQLAlchemy>=3
        return current_app.extensions['migrate'].db.engine


def get_engine_url():
    try:
        return get_engine().url.render_as_string(hide_password=False).replace(
            '%', '%%')
    except AttributeError:
        return str(get_engine().url).replace('%', '%%')


# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
config.set_main_option('sqlalchemy.url', get_engine_url())
target_db = current_app.extensions['migrate'].db

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def get_metadata():
    if hasattr(target_db, 'metadatas'):
        return target_db.metadatas[None]
    return target_db.metadata


def run_migrations_offline():
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url, target_metadata=get_metadata(), literal_binds=True
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online():
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """

    # this callback is used to prevent an auto-migration from being generated
    # when there are no changes to the schema
    # reference: http://alembic.zzzcomputing.com/en/latest/cookbook.html
    def process_revision_directives(context, revision, directives):
        if getattr(config.cmd_opts, 'autogenerate', False):
            script = directives[0]
            if script.upgrade_ops.is_empty():
                directives[:] = []
                logger.info('No changes in schema detected.')

    conf_args = current_app.extensions['migrate'].configure_args
    if conf_args.get("process_revision_directives") is None:
        conf_args["process_revision_directives"] = process_revision_directives

    connectable = get_engine()

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=get_metadata(),
            **conf_args
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()


################################################################################
File: ./migrations/versions/4ab810f9beb5_initial_migration.py
"""Initial migration

Revision ID: 4ab810f9beb5
Revises: add_split_screen_to_photo
Create Date: 2024-06-12 20:04:25.161696

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '4ab810f9beb5'
down_revision = 'add_split_screen_to_photo'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('device',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('device_name', sa.String(length=100), nullable=False),
    sa.Column('device_type', sa.String(length=50), nullable=False),
    sa.Column('status', sa.String(length=50), nullable=False),
    sa.Column('ip_address', sa.String(length=50), nullable=False),
    sa.Column('photo_update_frequency', sa.Integer(), nullable=True),
    sa.Column('random_order', sa.Boolean(), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('photo',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('photo_name', sa.String(length=100), nullable=False),
    sa.Column('path', sa.String(length=200), nullable=False),
    sa.Column('rotation', sa.Integer(), nullable=True),
    sa.Column('scaling', sa.Integer(), nullable=True),
    sa.Column('window_x', sa.Integer(), nullable=True),
    sa.Column('window_y', sa.Integer(), nullable=True),
    sa.Column('split_screen_x', sa.Integer(), nullable=True),
    sa.Column('split_screen_y', sa.Integer(), nullable=True),
    sa.Column('split_screen_width', sa.Integer(), nullable=True),
    sa.Column('split_screen_height', sa.Integer(), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('photo_device',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('photo_id', sa.Integer(), nullable=False),
    sa.Column('device_id', sa.Integer(), nullable=False),
    sa.ForeignKeyConstraint(['device_id'], ['device.id'], ),
    sa.ForeignKeyConstraint(['photo_id'], ['photo.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('photo_device')
    op.drop_table('photo')
    op.drop_table('device')
    # ### end Alembic commands ###


################################################################################
File: ./migrations/versions/2024-06-12_add_split_screen_to_photo.py
from alembic import op
import sqlalchemy as sa

revision = 'add_split_screen_to_photo'
down_revision = 'c7e6147d997f'

def upgrade():
    with op.batch_alter_table('photo', schema=None) as batch_op:
        batch_op.add_column(sa.Column('split_screen_x', sa.Integer(), nullable=True))
        batch_op.add_column(sa.Column('split_screen_y', sa.Integer(), nullable=True))
        batch_op.add_column(sa.Column('split_screen_width', sa.Integer(), nullable=True))
        batch_op.add_column(sa.Column('split_screen_height', sa.Integer(), nullable=True))

def downgrade():
    with op.batch_alter_table('photo', schema=None) as batch_op:
        batch_op.drop_column('split_screen_x')
        batch_op.drop_column('split_screen_y')
        batch_op.drop_column('split_screen_width')
        batch_op.drop_column('split_screen_height')


################################################################################
File: ./migrations/versions/c7e6147d997f_add_photo_update_frequency_and_random_.py
"""Add photo_update_frequency and random_order to Device model

Revision ID: c7e6147d997f
Revises: 
Create Date: 2024-06-01 14:06:11.953731

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'c7e6147d997f'
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('device', schema=None) as batch_op:
        batch_op.add_column(sa.Column('photo_update_frequency', sa.Integer(), nullable=True))
        batch_op.add_column(sa.Column('random_order', sa.Boolean(), nullable=True))

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('device', schema=None) as batch_op:
        batch_op.drop_column('random_order')
        batch_op.drop_column('photo_update_frequency')

    # ### end Alembic commands ###


################################################################################
File: ./test/gpio_test.py
import RPi.GPIO as GPIO
import time

BUTTON_PIN = 16

GPIO.setmode(GPIO.BCM)
GPIO.setup(BUTTON_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)

previous_state = GPIO.HIGH

try:
	while True:
		current_state = GPIO.input(BUTTON_PIN)
		if previous_state==GPIO.HIGH and current_state == GPIO.LOW:
			print("Button Pressed")
		
		previous_state = current_state
		
		time.sleep(1)
except KeyboardInterrupt:
	Pass
finally:
	GPIO.cleanup()


################################################################################
File: ./test/bluetooth_test.py
import bluetooth

server_address = "B8:27:EB:81:31:84"

sock = bluetooth.BluetoothSocket(bluetooth.RFCOMM)
sock.connect((server_address,1))

message = "Hello, Raspberry Pi Zero W!"
sock.send(message)

print(f"Sent: {message}")

sock.close()


################################################################################
File: ./test/create_image.py
import time
import os
import tkinter as tk
from PIL import Image, ImageTk, ImageDraw, ImageFont
from threading import Thread
import queue
import RPi.GPIO as GPIO
import subprocess
import socket
import pyautogui
import re

current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
wireless_dir = os.path.join(parent_dir,'wireless')
bluetooth_script = os.path.join(wireless_dir,'bluetooth_connection.py')
wireless_script = os.path.join(wireless_dir,'wifi_connection.py')
next_file_path = os.path.join(current_dir,'displayed_photo','next.jpg')
current_file_path = os.path.join(current_dir,'displayed_photo','current.jpg')
init_file_path = os.path.join(current_dir,'logo.jpg')
hostname_file_path = os.path.join(current_dir,'hostname_display.jpg')


line = "WIFI: Dan’s 13 ProMax 12345679"
match = re.match(r"WIFI: (.+) (\S+)$", line)
if match:
	ssid = match.group(1)
	psk = match.group(2)
	print(f"SSID: {ssid}")
	print(f"PSK: {psk}")
	
result = subprocess.run(['sudo','python3',wireless_script,ssid,psk],capture_output=True,text=True)
if result.returncode != 0:
	print(f"Error running wireless script:\n{result.stderr}")
else:
	print(f"Wireless script successful:\n{result.stdout}")


################################################################################
File: ./test/bluetooth_discover_test.py
import bluetooth

nearby_devices = bluetooth.discover_devices(lookup_names=True)

print(f"Found {len(nearby_devices)} devices")

for addr, name in nearby_devices:
	print(f"	{addr} - {name}")


################################################################################
File: ./test/photo_format_test.py
import tkinter as tk
from PIL import Image, ImageTk, ExifTags
import os
        
if __name__ == "__main__":
           
    photo = Image.open("Photo_8.jpg")
    
    try:
        for orientation in ExifTags.TAGS.keys():
            if ExifTags.TAGS[orientation] == 'Orientation':
                break
        exif = photo._getexif()
        if exif is not None:
            orientation = exif.get(orientation,1)
            if orientation == 3:
                photo = photo.rotate(180, expand=True)
            elif orientation == 6:
                photo = photo.rotate(270, expand=True)
            elif orientation == 8:
                photo = photo.rotate(90, expand=True)
    except (AttributeError, KeyError, IndexError):
        pass
    
    scaling = 75
    if scaling != 100:
        w, h = photo.size
        w, h = (int)(w*scaling/100), (int)(h*scaling/100)
        photo = photo.resize((w,h),resample=Image.NEAREST)
    
    left = 55
    top = 350
    right = left+1024
    bottom = top+600
    
    photo = photo.crop((left,top,right,bottom))
    photo.save("photo_test.jpg")
    
def suppress_auto_rotate(photo):
    
    try:
        for orientation in ExifTags.TAGS.keys():
            print(ExifTags.TAGS[orientation])
            if ExifTags.TAGS[orientation] == 'Orientation':
                break
        exif = photo._getexif()
        print(exif)
        if exif is not None:
            orientation = exif.get(orientation,1)
            if orientation == 3:
                photo = photo.rotate(180, expand=True)
            elif orientation == 6:
                photo = photo.rotate(270, expand=True)
            elif orientation == 8:
                photo = photo.rotate(90, expand=True)
    except (AttributeError, KeyError, IndexError):
        pass
    
    return photo
    
        
        
        
        
        
        



################################################################################
File: ./test/blend_transition_frame_controller.py
import time
import os
import tkinter as tk
from PIL import Image, ImageTk
from threading import Thread
import queue

#current_photo = None
#next_photo = None
#update = False
#alpha = 0.0

current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
next_file_path = os.path.join(current_dir,'displayed_photo','next.jpg')
current_file_path = os.path.join(current_dir,'displayed_photo','current.jpg')
init_file_path = os.path.join(current_dir,'logo.jpg')
   
def frame_control(q):
    
    #global current_photo
    #global next_photo
    #global update
        
    time.sleep(5)
           
    while True:
 
        if os.path.exists(next_file_path):
            #next_photo = Image.open(next_file_path)
            #if current_photo is None:
                #current_photo = next_photo
            #update = True
            
            try:
                if os.path.exists(current_file_path):
                    os.remove(current_file_path)
                os.rename(next_file_path,current_file_path)
                q.put(current_file_path)
            except Exception as e:
                print(f"An error occurred: {e}")

        time.sleep(1)
    
'''def update_display(image_label):
    
    global current_photo
    global next_photo
    global update
    global alpha
    
    if update and next_photo is not None and current_photo is not None:
        photo = Image.blend(current_photo, next_photo, alpha)
        alpha += 0.05
        if alpha >= 1.0:
            alpha = 0.0
            current_photo = next_photo
            display = ImageTk.PhotoImage(current_photo)
            image_label.config(image=display)
            image_label.image = display
            update = False
        else:
            image_label.after(50, update_display, image_label)
            display = ImageTk.PhotoImage(photo)
            image_label.config(image=display)
            image_label.image = display
            return
    
    image_label.after(1000, update_display, image_label)'''
    
def update_display(image_label, q):
    
    try:
        image_path = q.get_nowait()
        if os.path.exists(image_path):
            image = Image.open(image_path)
            display = ImageTk.PhotoImage(image)
            image_label.config(image=display)
            image_label.image = display
    except queue.Empty:
        pass
    
    image_label.after(1000, update_display, image_label, q)
  
def start_frame_controller():
           
    root = tk.Tk()
    root.geometry("1024x600")
    
    image_label = tk.Label(root)
    image_label.pack(fill=tk.BOTH, expand=True)
    
    q = queue.Queue(maxsize=1)
    q.put(init_file_path)
        
    update_thread = Thread(target=frame_control,args=(q,),daemon=True)
    update_thread.start()
        
    update_display(image_label, q)
    
    root.mainloop()

    

    
    


################################################################################
File: ./test/GUI_Test3.py
import tkinter as tk
from PIL import Image, ImageTk
import os

class ImageSliderApp:
    def __init__(self, root, image1, image2, image3, hold=5000):
        self.root = root
        self.image1 = image1
        self.image2 = image2
        self.image3 = image3
        self.hold = hold
        self.interval = 10
        self.alpha = 0.0
        self.current_image = image1
        self.next_image = image2
        self.is_image1 = True
        self.counter = 1
        
        self.root.attributes('-fullscreen', True)
        self.root.bind('<Escape>', self.exit_fullscreen)
        
        self.image_label = tk.Label(root)
        self.image_label.pack(fill=tk.BOTH, expand=True)
        
        self.show_current_image()
        
        self.root.after(self.hold, self.transition)
        
    def exit_fullscreen(self, event=None):
        self.root.attributes('-fullscreen', False)
        
    def show_current_image(self):
        self.photo = ImageTk.PhotoImage(self.current_image)
        self.image_label.config(image=self.photo)
        
    def blend_images(self):
        blended_image = Image.blend(self.current_image, self.next_image, self.alpha)
        self.photo = ImageTk.PhotoImage(blended_image)
        self.image_label.config(image=self.photo)
    
    def transition(self):
 
        self.alpha += 0.05
        if self.alpha >= 1.0:
            self.alpha = 0.0
            if self.counter == 1:
                self.current_image = self.image2
                self.next_image = self.image3
                self.counter = 2;
            elif self.counter == 2:
                self.current_image = self.image3
                self.next_image = self.image1
                self.counter = 3;
            else:
                self.current_image = self.image1
                self.next_image = self.image2
                self.counter = 1;
            
            
            '''temp = self.current_image
            self.current_image = self.next_image
            self.next_image = temp'''
            
            self.show_current_image()
            self.root.after(5000, self.transition)
        else:
            self.blend_images()
            self.root.after(self.interval, self.transition)
        
if __name__ == "__main__":
    
    root = tk.Tk()
    
    pic = Image.open("picture.jpg")
    w, h = pic.size
    neww = (int)(w/2)
    newh = (int)(h/2)
    resize_pic = pic.resize((neww,newh),resample=Image.NEAREST)
    w, h = resize_pic.size
    centerX = w/2
    centerY = h/2-50
    left = centerX - 512
    right = centerX + 512
    top = centerY - 300
    bottom = centerY + 300
    crop_pic = resize_pic.crop((left,top,right,bottom))

    pic2 = Image.open("picture2.jpg")
    pic2 = pic2.transpose(Image.ROTATE_270)
    w2, h2 = pic2.size
    ratio2 = w2/1024
    neww2 = (int)(1024)
    newh2 = (int)(h2/ratio2)
    resize_pic2 = pic2.resize((neww2,newh2),resample=Image.NEAREST)
    w2, h2 = resize_pic.size
    centerX2 = w2/2
    centerY2 = h2/2+200
    left2 = centerX2 - 512
    right2 = centerX2 + 512
    top2 = centerY2 - 300
    bottom2 = centerY2 + 300
    crop_pic2 = resize_pic2.crop((left2,top2,right2,bottom2))
    
    pic3 = Image.open("picture3.jpg")
    pic3 = pic3.transpose(Image.ROTATE_270)
    w3, h3 = pic3.size
    ratio3 = w3/1024
    neww3 = (int)(1024)
    newh3 = (int)(h3/ratio3)
    resize_pic3 = pic3.resize((neww3,newh3),resample=Image.NEAREST)
    w3, h3 = resize_pic3.size
    centerX3 = w3/2
    centerY3 = h3/2
    left3 = centerX3 - 512
    right3 = centerX3 + 512
    top3 = centerY3 - 300
    bottom3 = centerY3 + 300
    crop_pic3 = resize_pic3.crop((left3,top3,right3,bottom3))
    
    app = ImageSliderApp(root, crop_pic, crop_pic2, crop_pic3)
    root.mainloop()
        
        
        
        
        
        


################################################################################
File: ./test/random_string.py
import secrets
import string

alphabet = string.ascii_letters+string.digits
new_filename = ''.join(secrets.choice(alphabet) for _ in range(10))+'.jpg'

print(new_filename)


################################################################################
File: ./test/bluetoothsocket.py
import bluetooth
import os
import subprocess

if os.geteuid() != 0:
		print("This script must be run as root")
		exit(1)

# Set socket to listen for bluetooth connection from app or web portal
server_socket = bluetooth.BluetoothSocket(bluetooth.RFCOMM)

port = 1
server_socket.bind(("", port))

server_socket.listen(1)
port = server_socket.getsockname()[1]

server_socket.settimeout(5)

# Advertise service with UUID for bluetooth connection from app
bluetooth.advertise_service(server_socket, "Pi4Server",
							service_id = "00001101-0000-1000-8000-00805F9B34FB",
							service_classes = ["00001101-0000-1000-8000-00805F9B34FB", bluetooth.SERIAL_PORT_CLASS],
							profiles = [bluetooth.SERIAL_PORT_PROFILE])
							
print("Bluetooth service advertised. Waiting for connection...")							

try:
	# Get socket and address from device trying to connect
	client_socket, address = server_socket.accept()
except bluetooth.BluetoothError as e:
	print("No connection was made within the timeout period")
	server_socket.close()
	exit(1)

ssid = None
psk = None

try:

	# Read wifi credential info sent from connected device
	data = client_socket.recv(1024).decode('utf-8')
	if len(data) == 0:
		exit
	recieved_data = data.split("/n")

	ssid = recieved_data[0]
	psk = recieved_data[1]

except OSError:
	pass

# Run command to connect to wifi network
try:
		print("connecting...")
		subprocess.run(['nmcli', 'dev', 'wifi', 'connect', ssid, 'password', psk], check=True)
		client_socket.send("OK")

except subprocess.CalledProcessError as e:
		print('Failed to connect')
		client_socket.send("Failed to connect")
		exit(1)

client_socket.close()
server_socket.close()

# Restart avahi-daemon just in case to make sure rpi hostname is advertised so enumerate_wifi_devices can read it
subprocess.run(['sudo', 'systemctl', 'restart', 'avahi-daemon'], check=True)







################################################################################
File: ./web/web_server.py
from flask import Flask, request, jsonify, send_file, render_template, redirect, url_for, send_from_directory
import os
import sys
import socket
import subprocess
import json
import secrets
import string
#import netifaces as ni
#from OpenSSL import SSL

current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
device_config_path = os.path.join(parent_dir,'device_config.json')
photo_config_path = os.path.join(parent_dir,'photo_config.json')
principal_dir = os.path.join(parent_dir,'principal')
photo_library_path = os.path.join(parent_dir,'photo_library')
wireless_dir = os.path.join(parent_dir,'wireless')
upate_dns_script_path = os.path.join(current_dir,'update_dns.py')
sys.path.append(principal_dir)
sys.path.append(wireless_dir)

from framecast_classes import json_parse_device_collection, json_parse_photo_collection, build_device_collection_from_json, build_photo_collection_from_json, get_device_config, get_photo_config, update_device, update_photo, add_new_devices, get_connection_status, add_new_photos, update_device_connection_status, update_photos_from_mobile, update_devices_from_mobile, remove_devices, remove_photos
from photo_formatter import format_photo_for_edit_window, format_photo_for_preview
from api import DigitalPhotoFrameAPI

app = Flask(__name__)

# External API calls from mobile app

@app.route('/send_device_config', methods=['POST'])
def receive_device_config():
    #print(request.headers)
    #print(request.data.decode('utf-8'))
    data = request.data.decode('utf-8')
    print(data)
    update_devices_from_mobile(data)
        
    return jsonify({'status':'String received','data':data}), 200
    
@app.route('/send_photo_config', methods=['POST'])
def receive_photo_config():
    data = request.data.decode('utf-8')
    update_photos_from_mobile(data)
        
    return jsonify({'status':'String received','data':data}), 200

@app.route('/send_photo', methods=['POST'])
def receive_image():
    if 'image' not in request.files:
        return jsonify({'status':'No file part'}), 400
    file = request.files['image']
    print(file.filename)
    if file.filename == '':
        return jsonify({'status':'No selected file'}), 400
    photo_path = os.path.join(parent_dir,'photo_library',file.filename)
    file.save(photo_path)
    return jsonify({'status':'Image received','filename':file.filename}), 200

@app.route('/get_device_config', methods=['GET'])
def load_device_config():
    config = get_device_config(device_config_path)
    return config
    
@app.route('/get_photo_config', methods=['GET'])
def load_photo_config():
    config = get_photo_config(photo_config_path)
    return config

@app.route('/get_config', methods=['GET'])
def load_config():
    deviceConfig = json.loads(get_device_config(device_config_path))
    photoConfig = json.loads(get_photo_config(photo_config_path))
    config = {
        "Device Config":deviceConfig,
        "Photo Config":photoConfig
    }
    print(f"Combined config:{json.dumps(config)}")
    return json.dumps(config)

@app.route('/get_photo/<path:filename>', methods=['GET'])
def get_photo(filename):

    photo_path = os.path.join(parent_dir,'photo_library',filename)
    if os.path.exists(image_path):
        return send_file(photo_path,mimetype='image/jpeg')
    else:
        return "Image not found", 404
        
# Start integration
        
@app.route('/')
def index():
    return redirect(url_for('device_manager'))
    
@app.route('/device_manager')
def device_manager():
    return render_template('device_manager.html')
    
@app.route('/device_editor')
def device_editor():
    return render_template('device_editor.html')
    
@app.route('/photo_editor')
def photo_editor():
    return render_template('photo_editor.html')

# API endpoint to save device configuration
@app.route('/api/save_device_config', methods=['POST'])
def save_device_config():
    data = request.json
    print(f"Saving device config: {data}")
    
    config = update_device(data)
    
    print(config)
    
    return config

    return jsonify({"success": True})
    #else:
    return jsonify({"error": "Device not found"}), 404
    
@app.route('/api/save_photo_config', methods=['POST'])
def save_photo_config():
    data = request.json
    print(f"Saving photo config: {data}")
    
    config = update_photo(data)
    
    print(config)
    
    return config

    return jsonify({"success": True})
    #else:
    return jsonify({"error": "Device not found"}), 404

'''@app.route('/photo_library/<path:filename>', methods=['GET'])
def photo_library(filename):
    print("photo_library")
    photo_path = os.path.join('../photo_library',filename)
    
    photo = get_single_photo_config(filename)
    
    if photo is None:
        print(filename)
    
    scaling = get_single_photo_config(filename).get_scaling()
    
    #print(get_single_photo_config(filename).get_scaling())
    
    #format_photo_for_edit_window(photo_path)    
    return send_file(format_photo_for_edit_window(photo_path,scaling),mimetype='image/jpeg')'''
    
@app.route('/photo_library/<filename>/<scaling>', methods=['GET'])
def get_scaled_photo(filename,scaling):

    #print(f"Scaling value: {scaling}")
    #photo_path = os.path.join('../photo_library',filename)
    photo_path = os.path.join(parent_dir,'photo_library',filename)
    return send_file(format_photo_for_edit_window(photo_path,scaling),mimetype='image/jpeg')
    
@app.route('/photo_preview/<path:filename>', methods=['GET'])
def get_photo_preview(filename):

    photo_path = os.path.join(parent_dir,'photo_library',filename)
    return send_file(format_photo_for_preview(photo_path),mimetype='image/jpeg')

@app.route('/api/update_dns', methods=['GET'])
def update_dns():
    
    try:
        result = subprocess.run(['sudo', 'python3', upate_dns_script_path], check=True, text=True, capture_output=True)
        print("Script output:",result.stdout)
        print("Script error output (if any):",result.stderr)
        return jsonify({"message":"IP address updated successfully"}), 200
    except subprocess.CalledProcessError as e:
        print(f"Failed to run the script: {e}")
        return jsonify({"message":"IP address update failed"}), 404

@app.route('/api/find_discoverable_bluetooth_devices', methods=['GET'])
def find_discoverable_bluetooth_devices():
    
    print("/api/find_discoverable_bluetooth_devices")
    discovered_devices = DigitalPhotoFrameAPI.find_discoverable_bluetooth_devices()
    print("Result of find_discoverable_bluetooth_devices:")
    print(discovered_devices)
    return discovered_devices
    
@app.route('/api/invite_discovered_devices_to_network', methods=['POST'])
def invite_discovered_devices_to_network():
    
    print("/api/invite_discovered_devices_to_network")
    invited_devices = request.json
    print("Result of request.json:")
    print(invited_devices)
    connection_confirmation = DigitalPhotoFrameAPI.invite_discovered_devices_to_network(invited_devices)
    print("Result of invite_discovered_devices_to_network:")
    print(invited_devices)
    updated_collection = add_new_devices(invited_devices)
    print("Result of add_new_devices:")
    print(updated_collection)
    return updated_collection

@app.route('/api/enumerate_wifi_devices', methods=['GET'])
def enumerate_wifi_devices():
    
    print("/api/enumerate_wifi_devices")
    networked_devices = DigitalPhotoFrameAPI.enumerate_wifi_devices()
    print("Result of enumerate_wifi_devices:")
    print(networked_devices)
    updated_collection = get_connection_status(networked_devices)
    print("Result of get_connection_status:")
    print(updated_collection)
    return updated_collection
    
@app.route('/api/upload_photos', methods=['POST'])
def upload_photos():
    
    print("/api/upload_photos")
    if 'files[]' not in request.files:
        return redirect(request.url)
    
    files = request.files.getlist('files[]')
    photo_names = []
    
    for file in files:
        if file and file.filename.endswith('.jpg'):
            alphabet = string.ascii_letters+string.digits
            new_filename = ''.join(secrets.choice(alphabet) for _ in range(10))+'.jpg'
            file.save(os.path.join(photo_library_path,new_filename))
            photo_names.append(new_filename)
    
    print("Result of file iteration:")
    print(photo_names)
    
    if len(photo_names) != 0:
        photo_config = add_new_photos(photo_names)
        print("Result of add_new_photos:")
        print(photo_config)
    
    return redirect(url_for('photo_editor'))
    
@app.route('/api/update_connection_status', methods=['POST'])
def update_connection_status():
    data = request.json
    print(f"Updating connection status: {data}")
    
    config = update_device_connection_status(data)
    
    print(f"Config after update_device_connection_status:\n{config}")

    return jsonify({"success": True})
    
@app.route('/api/delete_devices', methods=['POST'])
def delete_devices():
    data = request.json
    print(f"delete_devices: {data}")
    
    config = remove_devices(data)
    
    print(f"Config after remove_devices:\n{config}")

    return config

@app.route('/api/delete_photos', methods=['POST'])
def delete_photos():
    data = request.json
    print(f"delete_photos: {data}")
    
    config = remove_photos(data)
    
    print(f"Config after remove_photos:\n{config}")

    return config

def start_web_server():
    
    app.run(host='0.0.0.0',port=5000, debug=False,use_reloader=False)


if __name__ == '__main__':
    #context = ('cert.pem', 'key.pem')
    #update_dns()
    app.run(host='0.0.0.0', port=5000, debug=True)
    #app.run(host='0.0.0.0', port=5000, ssl_context=context)
    
    


################################################################################
File: ./web/update_dns.py
import socket
import os

def get_ip_address():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        # Unreachable ID address to force socket open
        s.connect(('10.254.254.254',1))
        IP = s.getsockname()[0]
    except Exception:
        IP = '127.0.0.1'
    finally:
        s.close()
    
    print(IP)
    return IP
    
def update_dns(ip):
    ip_mapped = False
    config_line = f"address=/framecast.local/{ip}"
    with open("/etc/dnsmasq.conf","r") as file:
        lines = file.readlines()
    
    with open("/etc/dnsmasq.conf", "w") as file:
        for line in lines:
            print(line)
            if "address=/framecast.local/" in line:
                print("Replacing line...")
                file.write(config_line+"\n")
                ip_mapped = True
            else:
                file.write(line)
        if not ip_mapped:
            print("Adding line...")
            file.write(config_line + "\n")
    
    os.system("sudo systemctl restart dnsmasq")

if __name__ == '__main__':
	update_dns(get_ip_address())


################################################################################
File: ./web/static/photo_editor.css
/* General Styles */
body {
  font-family: 'Inter', sans-serif;
  margin: 0;
  padding: 0;
  background-color: #fff;
  text-align: center;
  display: flex;
  flex-direction: column;
}

/* Navbar Styles */
.navbar {
  display: flex;
  justify-content: space-around;
  padding: 20px;
  background-color: #d9d9d9;
  border-bottom: 4px solid #000;
  width: 100%;
  box-sizing: border-box;
}

.navbar-item {
  margin: 0;
  padding: 5px;
  font-size: 24px;
  font-weight: 800;
  cursor: pointer;
  text-decoration: none; /* Remove underline */
  color: inherit; /* Remove blue color */
  transition: transform 0.3s ease, color 0.3s ease;
}

.navbar-item:hover {
  transform: scale(1.1);
  color: #ff6f61;
}

.navbar-item.highlight {
  background-color: #ffeb3b;
  padding: 5px;
  border-radius: 5px;
}

/* Main Content Styles */
.main-content {
  display: flex;
  flex-direction: row;
  align-items: flex-start;
  justify-content: space-around;
  padding: 20px;
  gap: 20px;
  width: 100%;
  box-sizing: border-box;
}

.section-title {
  font-size: 24px;
  font-weight: 800;
  margin-bottom: 20px;
}

/* Photo Editor Specific Styles */
.photo-list-section,
.photo-display-panel {
  display: flex;
  flex-direction: column;
  align-items: center;
  border: 4px solid #000;
  padding: 20px;
  background-color: #d9d9d9;
  box-sizing: border-box;
  flex: 1;
}

.photo-list {
  display: flex;
  flex-direction: column;
  gap: 5px;
  margin-bottom: 20px;
}

.photo-controls {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 10px;
  margin-bottom: 20px;
  border: 4px solid #000;
  padding: 10px;
  background-color: #d9d9d9; /* Gray background */
  box-sizing: border-box;
  flex: 1;
}

.action-button {
  padding: 10px 20px;
  margin: 20px;
  border: none;
  background-color: #a9a9a9;
  font-size: 16px;
  cursor: pointer;
  transition: background-color 0.3s ease, transform 0.3s ease;
}

.action-button:hover {
  background-color: #8c8c8c;
  transform: scale(1.05);
}

.scale-input {
  width: 60px;
  text-align: center;
  padding: 5px;
  border: 1px solid #000;
}

.photo-container {
  display: flex;
  position: relative;
  width: 800px;
  height: 400px;
  border: 2px solid #000;
  overflow: auto;
  justify-content: flex-start;
  align-items: flex-start;
}

.preview-image {
  position: relative;
  max-width: none;
  max-height:none;
  width: auto;
  height: auto;
  object-fit: none;
  transform: scale(1.0);
  transform-original: top left;
  display: none;
}

.window-box {
  position: absolute;
  cursor: grab;
  border: 2px solid red;
  background-color: rgba(0,0,0,0.0);
  width: 510px;
  height: 298px;
  top: 0;
  left: 0;
}

input[type="file"]{
  display: none;
}

li {
  padding: 10px;
  border: 1px solid #ddd;
  margin-top: -1px;
  cursor: point;
}

li:hover {
  background-color: #f0f0f0;
}

.selected {
  background-color: #f0f0f0;
}

.last-selected {
  background-color: #add8e6;
}

/* Responsive Styles */
@media screen and (max-width: 1200px) {
  .main-content {
    flex-direction: column;
    align-items: center;
  }

  .photo-list-section,
  .photo-display-panel {
    width: 100%;
  }

  .preview-image {
    width: 80px;
    height: 80px;
  }
}

@media screen and (max-width: 768px) {
  .main-content {
    flex-direction: column;
    align-items: center;
    padding: 10px;
  }

  .photo-list-section,
  .photo-display-panel {
    width: 100%;
    padding: 10px;
  }

  .section-title {
    font-size: 20px;
  }

  .preview-image {
    width: 60px;
    height: 60px;
  }

  .action-button {
    padding: 5px;
    font-size: 14px;
  }

  .scale-input {
    width: 50px;
  }
}

@media screen and (max-width: 480px) {
  .main-content {
    padding: 5px;
  }

  .photo-list-section,
  .photo-display-panel {
    padding: 5px;
  }

  .section-title {
    font-size: 14px;
  }

  .preview-image {
    width: 50px;
    height: 50px;
  }

  .action-button {
    padding: 3px;
    font-size: 12px;
  }

  .scale-input {
    width: 40px;
  }
}

@media screen and (max-width: 768px) {
  .navbar-item {
    font-size: 18px;
    margin: 10px 0;
  }
}


################################################################################
File: ./web/static/device_manager.css
/* General Styles */
body {
  font-family: 'Inter', sans-serif;
  margin: 0;
  padding: 0;
  background-color: #fff;
  text-align: center;
  display: flex;
  flex-direction: column;
}

li {
  padding: 10px;
  border: 1px solid #ddd;
  margin-top: -1px;
  cursor: point;
}

li:hover {
  background-color: #f0f0f0;
}

.selected {
  background-color: #f0f0f0;
}

table {

  width: 80%;
  margin: 20px auto;
  border-collapse: collapse;
}

th, td {
  padding: 10px;
  border: 1px solid #ddd;
  text-align: center;
}

th {
  background-color: #f4f4f4;
}

.selected {
  background-color: #f0f0f0;
}

/* Navbar Styles */
.navbar {
  display: flex;
  justify-content: space-around;
  padding: 20px;
  background-color: #d9d9d9;
  border-bottom: 4px solid #000;
  width: 100%;
  box-sizing: border-box;
  text-decoration: none;
}

.navbar-item {
  margin: 0;
  padding: 5px;
  font-size: 24px;
  font-weight: 800;
  cursor: pointer;
  transition: transform 0.3s ease, color 0.3s ease;
  text-decoration: none;
  color: inherit;
}

.navbar-item:hover {
  transform: scale(1.1);
  color: #ff6f61;
}

.highlight {
  background-color: #ffeb3b;
  padding: 5px;
  border-radius: 5px;
}

/* Main Content Styles */
.main-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 20px;
  gap: 10px;
  width: 100%;
  box-sizing: border-box;
}

.devices-section {
  width: 80%;
  border: 4px solid #000;
  padding: 20px;
  background-color: #d9d9d9;
  box-sizing: border-box;
}

.section-title {
  font-size: 24px;
  font-weight: 800;
  margin-bottom: 20px;
}

.device-list-header {
  display: flex;
  justify-content: space-around;
  padding: 10px 0;
  background-color: #ccc;
  border-bottom: 2px solid #000;
  font-weight: 800;
}

.device-list {
  margin-bottom: 20px;
}

.device-item {
  margin-bottom: 10px;
  font-size: 16px;
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 10px;
  padding: 10px;
  border-bottom: 1px solid #000;
}

.action-button {
  padding: 10px 20px;
  margin: 10px;
  border: none;
  background-color: #a9a9a9;
  font-size: 16px;
  cursor: pointer;
  transition: background-color 0.3s ease, transform 0.3s ease;
}

.action-button:hover {
  background-color: #8c8c8c;
  transform: scale(1.05);
}

/* Responsive Styles for Screens with max-width 768px */
@media screen and (max-width: 768px) {
  .navbar {
    flex-direction: row;
    align-items: center;
  }

  .navbar-item {
    font-size: 18px;
    margin: 10px 0;
  }

  .devices-section {
    width: 100%;
    padding: 10px;
  }

  .section-title {
    font-size: 20px;
  }

  .device-item,
  .action-button {
    font-size: 14px;
  }

  .device-list-header {
    flex-direction: row;
    align-items: center;
  }
}

/* Responsive Styles for Screens with max-width 600px */
@media screen and (max-width: 600px) {
  .device-list-header {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
  }

  .device-list-header p {
    font-size: 14px;
  }
}


################################################################################
File: ./web/static/device_editor.css
/* General styles for the body */
body {
  font-family: 'Inter', sans-serif;
  margin: 0;
  padding: 0;
  background-color: #fff;
  text-align: center;
  display: flex;
  flex-direction: column;
}

li {
  padding: 10px;
  border: 1px solid #ddd;
  margin-top: -1px;
  cursor: point;
}

li:hover {
  background-color: #f0f0f0;
}

.selected {
  background-color: #f0f0f0;
}

.last-selected {
  background-color: #add8e6;
}



/* Navbar styles */
.navbar {
  display: flex;
  justify-content: space-around;
  padding: 20px;
  background-color: #d9d9d9;
  border-bottom: 4px solid #000;
  width: 100%;
  box-sizing: border-box;
  text-decoration: none;
}

/* Navbar item styles */
.navbar-item {
  margin: 0;
  padding: 5px;
  font-size: 24px;
  font-weight: 800;
  cursor: pointer;
  text-decoration: none;
  color: inherit;
  transition: transform 0.3s ease, color 0.3s ease;
}

/* Navbar item hover effect */
.navbar-item:hover {
  transform: scale(1.1);
  color: #ff6f61;
}

/* Highlighted navbar item */
.navbar-item.highlight {
  background-color: #ffeb3b;
  padding: 5px;
  border-radius: 5px;
}

/* Main content styles */
.main-content {
  display: flex;
  flex-direction: row;
  align-items: center;
  padding: 20px;
  gap: 10px;
  width: 100%;
  box-sizing: border-box;
}

/* Section title styles */
.section-title {
  font-size: 20px;
  font-weight: 800;
}

/* Styles for sections containing lists and configurations */
.photo-list-section,
.device-list-section,
.device-config-pane {
  display: flex;
  flex-direction: column;
  align-items: center;
  border: 4px solid #000;
  padding: 10px;
  background-color: #d9d9d9; /* Gray background */
  box-sizing: border-box;
  flex: 1;
}

/* List styles for photos, devices, and assigned photos */
.photo-list,
.device-list,
.assigned-photo-list {
  display: flex;
  flex-direction: column;
  gap: 5px;
  padding: 10px;
}

/* Configuration item and button group styles */
.config-item,
.button-group {
  margin-bottom: 10px;
}

/* Action button styles */
.action-button {
  padding: 10px 20px;
  margin: 10px;
  border: none;
  background-color: #a9a9a9;
  font-size: 16px;
  cursor: pointer;
  transition: background-color 0.3s ease, transform 0.3s ease;
}

/* Action button hover effect */
.action-button:hover {
  background-color: #8c8c8c;
  transform: scale(1.05);
}

/* Preview image styles */
.preview-image {
  max-width: 300px;
  max-height: 300px;
  display: none;
}

/* Preview section styles */
.preview {
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* Responsive styles for screens with a maximum width of 1200px */
@media screen and (max-width: 1200px) {
  .main-content {
    flex-direction: column;
    align-items: center;
  }

  .photo-list-section,
  .device-list-section,
  .device-config-pane {
    width: 100%;
  }

  .preview-image {
    width: 80px;
    height: 80px;
  }
}

/* Responsive styles for screens with a maximum width of 768px */
@media screen and (max-width: 768px) {
  .main-content {
    flex-direction: column;
    align-items: center;
    padding: 10px;
  }

  .photo-list-section,
  .device-list-section,
  .device-config-pane {
    width: 100%;
    padding: 5px;
  }

  .section-title {
    font-size: 20px;
  }

  .preview-image {
    width: 60px;
    height: 60px;
  }

  .action-button {
    font-size: 14px;
  }
}

/* Responsive styles for screens with a maximum width of 480px */
@media screen and (max-width: 480px) {
  .main-content {
    padding: 5px;
  }

  .photo-list-section,
  .device-list-section,
  .device-config-pane {
    padding: 10px;
  }

  .section-title {
    font-size: 20px;
  }

  .preview-image {
    width: 50px;
    height: 50px;
  }

  .action-button {
    padding: 3px;
    font-size: 14px;
  }
}

/* Responsive navbar styles for screens with a maximum width of 768px */
@media screen and (max-width: 768px) {
  .navbar {
    flex-direction: row;
    align-items: center;
  }
}

/* Responsive navbar item styles for screens with a maximum width of 768px */
@media screen and (max-width: 768px) {
  .navbar-item {
    font-size: 18px;
    margin: 10px 0;
  }
}


################################################################################
File: ./web/static/photo_editor.js
let selectedPhotoIndex = 0;

/**
 * Fetch all photos from the server and update the photo list in the UI
 */
 
 
async function loadPhotos(){
    
    try{
        const response = await fetch('/get_photo_config');
        const data = await response.json();
        digitalPhotoCollection = data;
    } catch (error){
        console.error('Error fetching data:', error)
    }
       
    populatePhotoList(digitalPhotoCollection);
    if(selectedPhotoIndex < digitalPhotoCollection.length){
        populatePhotoEditor(digitalPhotoCollection[selectedPhotoIndex]); 
    }
}

function populatePhotoList(digitalPhotoCollection){
    
    const photoList = document.getElementById('photo-list');
    const photos = photoList.getElementsByClassName('list-item');
    
    photoList.innerHTML = '';
    
    let lastSelectedPhoto = null;
    
    digitalPhotoCollection.forEach((photo, index) => {

        const listItem = document.createElement('li');
        listItem.classList.add('list-item');
        listItem.textContent = photo['Name'];
        listItem.addEventListener('click', () => {
            //Array.from(photos).forEach(i => i.classList.remove('selected'));
            listItem.classList.toggle('selected');
            if(listItem.classList.contains('selected')){
                if(lastSelectedPhoto && lastSelectedPhoto !== listItem){
                    lastSelectedPhoto.classList.remove('last-selected');
                } 
                
                listItem.classList.add('last-selected');
                lastSelectedPhoto = listItem;
                
            } else {
                if(lastSelectedPhoto === listItem){
                    listItem.classList.remove('last-selected');
                    lastSelectedPhoto = null;
                }
            }
            
            
            selectedPhotoIndex = index;
            populatePhotoEditor(photo);
        });
        
        photoList.appendChild(listItem);
    });
}

function populatePhotoEditor(photo) {
    
    //document.getElementById('device-name').value = device['Name'];
    
    //console.log(photo);
    
    const photoObject = document.getElementById("previewImage");
    const scaling = document.getElementById("photoScaleValue");
    
    scaling.value = photo["Scaling"];
    
    const photoName = photo["Name"];

    const newSrc = `../../photo_library/${photoName}/${scaling.value}`;
    
    photoObject.src = newSrc;
    photoObject.style.display = 'block';
    
    
    const box = document.getElementById("windowBox");
    
    console.log(photo["Window"]);
    console.log(photo["Window"]["x"]);
    
    x=photo["Window"]["x"]/2;
    y=photo["Window"]["y"]/2;
    
    console.log(`x: ${x}, y: ${y}`);
    
    box.style.left = `${x}px`;
    box.style.top = `${y}px`;
}

async function deletePhotos(){
    
    let photosToDelete = getSelectedPhotos();
    
    if(photosToDelete.length == 0) return;
    
    try{
        const response = await fetch('/api/delete_photos', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(photosToDelete)
        });
        const data = await response.json();
        console.log("Save response:", data);
        digitalPhotoCollection = data;
        console.log("DP Collection after API call:", digitalPhotoCollection);
    } catch (error){
        console.error('Error saving device configuration:', error)
    }
       
    populatePhotoList(digitalPhotoCollection);
    if(selectedPhotoIndex < digitalPhotoCollection.length){
        populatePhotoEditor(digitalPhotoCollection[selectedPhotoIndex]); 
    }
}

function getSelectedPhotos() {
    
    const photoList = document.getElementById('photo-list');
    const photos = photoList.getElementsByClassName('list-item');
    const selectedPhotos = [];
    Array.from(photos).forEach(photo => {
        if (photo.classList.contains('selected')) {
            selectedPhotos.push(photo.textContent);
        }
    });
    
    return selectedPhotos;
 
}
 
 
/**
 * Simulate uploading a new photo to the server
 */
async function uploadPhotos(files) {
    
    //const fileInput = document.getElementById('fileinput');
    const formData = new FormData();
    
    for (const file of files){
        formData.append('files[]', file);
    }
    
    const response = await fetch('/api/upload_photos',{
        method: 'POST',
        body: formData
    });
    
    if(response.ok){
        window.location.href='photo_editor';
        loadPhotos();
    } else {
        console.error('File upload failed');
    }
    
    
}


async function savePhotoConfig(){
    
    const box = document.getElementById("windowBox");
    const scaling = document.getElementById("photoScaleValue");
    
    scaling.value = Math.min(100,scaling.value);
    scaling.value = Math.max(10,scaling.value);
    
    let x = box.offsetLeft*2;
    let y = box.offsetTop*2;
    
    let photoConfig = {
        "Photo Index":selectedPhotoIndex,
        "Window": { x,y },
        "Scaling":scaling.value
    };

    console.log("Saving device configuration:", photoConfig);

    try{
        const response = await fetch('/api/save_photo_config', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(photoConfig)
        });
        const data = await response.json();
        console.log("Save response:", data);
        digitalPhotoCollection = data;
    } catch (error){
        console.error('Error saving device configuration:', error)
    }

    populatePhotoList(digitalPhotoCollection)
    if(selectedPhotoIndex < digitalPhotoCollection.length){
        populatePhotoEditor(digitalPhotoCollection[selectedPhotoIndex]); 
    }
    
}

function scalePhoto(){
        
    let photo = digitalPhotoCollection[selectedPhotoIndex]; 
    
    const photoObject = document.getElementById("previewImage");
    const scaling = document.getElementById("photoScaleValue");
    
    const photoName = photo["Name"];

    const newSrc = `../../photo_library/${photoName}/${scaling.value}`;
    
    console.log(newSrc);
    
    photoObject.src = newSrc;   
}



// Event listener for when the document content is loaded
document.addEventListener('DOMContentLoaded', () => {
    console.log("Document loaded, fetching initial data...");
    
    loadPhotos();
    
    const box = document.getElementById("windowBox");
    const panel = document.querySelector(".photo-container");
    const image = document.getElementById("previewImage");
    
    let offsetX, offsetY, initialX, initialY;
    
    box.addEventListener("mousedown", function(e) {
        
        offsetX = e.clientX - box.getBoundingClientRect().left;
        offsetY = e.clientY - box.getBoundingClientRect().top;
        //initialX = e.clientX;
        //initialY = e.clientY;
        box.style.cursor = "grabbing";
        
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);

    });
    
    function onMouseMove(e) {
        
        const panelRect = panel.getBoundingClientRect();
        const imageRect = previewImage.getBoundingClientRect();
        
        let x = e.clientX - offsetX - panelRect.left + panel.scrollLeft;
        let y = e.clientY - offsetY - panelRect.top + panel.scrollTop;
        
        x = Math.max(0, Math.min(x,image.width - box.offsetWidth));
        y = Math.max(0, Math.min(y,image.height - box.offsetHeight));
        
        //const x = e.clientX - offsetX;
        //const y = e.clientY - offsetY;
        
        box.style.left = `${x}px`;
        box.style.top = `${y}px`;
        
        console.log(`x: ${x}, y: ${y}`);
  
    }
    
    function onMouseUp() {
        
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
        box.style.cursor = "grab";
  
    }
    
    
    //getAllPhotos();
});

// Event listener for the upload button
document.getElementById('scalePhoto').addEventListener('click', scalePhoto);

//document.querySelector('.upload-button').addEventListener('click', uploadPhoto);

// Event listener for the save button
/*document.querySelector('.save').addEventListener('click', (event) => {
    savePhotoConfig(event.target.dataset.photoId);
});*/
document.querySelector('.save').addEventListener('click', savePhotoConfig);
document.getElementById('fileInput').addEventListener('change', function(){
    if(this.files.length > 0){
        uploadPhotos(this.files);
    }
});




################################################################################
File: ./web/static/device_manager.js
// Object to store discovered Bluetooth devices
let digitalPhotoFrameCollection = [];
let discoveredDevices = [];


// Event listener for when the document content is loaded
document.addEventListener('DOMContentLoaded', () => {
    
    const table = document.getElementById('data-table');
    table.addEventListener('click', (event) => {
        const row = event.target.closest('tr');
        if(!row || row.parentNode.nodeName === 'THEAD') return;
        row.classList.toggle('selected');
    });
    
    loadDevices();
});

// Start Dan's code

async function loadDevices(){
    
    try{
        const response = await fetch('/get_device_config');
        const data = await response.json();
        digitalPhotoFrameCollection = data;
    } catch (error){
        console.error('Error fetching data:', error)
    }
        
    refreshDevices();
}

async function refreshDevices(){
    
    try{
        const response = await fetch('/api/enumerate_wifi_devices');
        const data = await response.json();
        digitalPhotoFrameCollection = data;
    } catch (error){
        console.error('Error fetching data:', error)
    }
        
    buildTable(digitalPhotoFrameCollection);
    
}

function buildTable(digitalPhotoFrameCollection) {
    
    const tableBody = document.getElementById('data-table').getElementsByTagName('tbody')[0];
    tableBody.innerHTML = '';
            
    digitalPhotoFrameCollection.forEach(digitalPhotoFrame => {
        const row = document.createElement('tr');
                
        const fields = ['Name','IP Address','Connected'];
                
        fields.forEach(field => {
                    
            const cell = document.createElement('td');
            cell.textContent = digitalPhotoFrame[field];
            row.appendChild(cell);
        });
                
        tableBody.appendChild(row);
    });
}

async function findNewDevices(){
    
    try{
        const response = await fetch('/api/find_discoverable_bluetooth_devices');
        const data = await response.json();
        discoveredDevices = data;
    } catch (error){
        console.error('Error fetching data:', error)
    }

    populateDiscoveredDeviceList(discoveredDevices);
}

function populateDiscoveredDeviceList(discoveredDevices){
    
    const deviceList = document.getElementById('discovered-devices');
    deviceList.innerHTML = '';
    
    discoveredDevices.forEach((device, index) => {
 
        const listItem = document.createElement('li');
        listItem.classList.add('list-item');
        listItem.textContent = device['Host Name'];
        listItem.addEventListener('click', () => {
            listItem.classList.toggle('selected');
        });
        
        deviceList.appendChild(listItem);
    }); 
}

function getSelectedDiscoveredDevices() {
    
    const deviceList = document.getElementById('discovered-devices');
    const devices = deviceList.getElementsByClassName('list-item');
    let devicesToInvite = [];
    Array.from(devices).forEach((device, index) => {
        if (device.classList.contains('selected')) {
            devicesToInvite.push(discoveredDevices[index]);
        }
    });

    return devicesToInvite;
}

async function inviteToNetwork() {

    devicesToInvite = getSelectedDiscoveredDevices();
    
    try{
        const response = await fetch('/api/invite_discovered_devices_to_network', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(devicesToInvite)
        });
        const data = await response.json();
        console.log("Save response:", data);
        digitalPhotoFrameCollection = data;
    } catch (error){
        console.error('Error saving device configuration:', error)
    }
        
    refreshDevices();
    const deviceList = document.getElementById('discovered-devices');
    deviceList.innerHTML = '';
}

async function deleteDevices() {
    
    devicesToDelete = getSelectedNetworkedDevices();
    if(devicesToDelete.length == 0) return;
    
    try{
        const response = await fetch('/api/delete_devices', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(devicesToDelete)
        });
        const data = await response.json();
        console.log("Save response:", data);
        digitalPhotoFrameCollection = data;
    } catch (error){
        console.error('Error saving device configuration:', error)
    }
    
    refreshDevices();
}

function getSelectedNetworkedDevices() {
    
    const table = document.getElementById('data-table');
    
    const devices = table.getElementsByTagName('tr');
    devicesToDelete = [];
    Array.from(devices).forEach((device, index) => {
        if (device.classList.contains('selected')) {
            console.log("Selected device:", digitalPhotoFrameCollection[index-1]);
            devicesToDelete.push(digitalPhotoFrameCollection[index-1]);
        }
    });
    console.log("devicesToDelete:", devicesToDelete);
    return devicesToDelete;
}

// end



/**
 * Function to find new Bluetooth devices that are discoverable
 */
/*unction findNewDevices() {
    fetch('/api/find_discoverable_bluetooth_devices')
        .then(response => response.json())
        .then(data => {
            discoveredDevices = data;
            let discoveredDevicesElement = document.getElementById('discovered-devices');
            if (discoveredDevicesElement) {
                discoveredDevicesElement.innerHTML = '';
                // Populate the discovered devices element with the names of found devices
                for (let mac in data) {
                    let device = data[mac];
                    discoveredDevicesElement.innerHTML += `<p>${device.device_name}</p>`;
                }
            } else {
                console.error('Element "discovered-devices" not found');
            }
        })
        .catch(error => console.error('Error finding new devices:', error));
}*/

/**
 * Function to invite discovered Bluetooth devices to join the network
 */
/*function inviteToNetwork() {
    fetch('/api/invite_to_network', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(Object.keys(discoveredDevices))
    })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                console.log("Devices successfully invited to network");
                findWiFiDevices();
            } else {
                console.log("Failed to invite devices");
            }
        })
        .catch(error => console.error("Error inviting devices:", error));
}*/

/**
 * Function to find devices connected to the WiFi network
 */
/*function findWiFiDevices() {
    fetch('/api/enumerate_wifi_devices')
        .then(response => response.json())
        .then(data => {
            let networkedDevices = document.getElementById('networked-devices');
            if (networkedDevices) {
                networkedDevices.innerHTML = '';
                // Populate the networked devices element with the details of connected devices
                for (let sn in data) {
                    let device = data[sn];
                    networkedDevices.innerHTML += `
                        <div class="device-item">
                            <p>${device.device_name}</p>
                            <p>${device.device_type}</p>
                            <p>${device.status}</p>
                            <p>${device.ip_address}</p>
                        </div>`;
                }
            } else {
                console.error('Element "networked-devices" not found');
            }
        })
        .catch(error => console.error('Error finding WiFi devices:', error));
}*/





################################################################################
File: ./web/static/device_editor.js

let digitalPhotoFrameCollection = [];
let digitalPhotoCollection = [];
let selectedDeviceIndex = 0;
let selectedPhotoIndex = 0;
let selectedAssignedPhotoIndex = -1;

// Event listener for when the document content is loaded
document.addEventListener('DOMContentLoaded', () => {
    console.log("Document loaded, fetching initial data...");
    loadPhotos();
    loadDevices();
});


// Start Dan's code

async function loadDevices(){
    
    try{
        const response = await fetch('/get_device_config');
        const data = await response.json();
        digitalPhotoFrameCollection = data;
    } catch (error){
        console.error('Error fetching data:', error)
    }
    
    /*fetch('/get_device_config')
        .then(response => response.json())
        .then(data => {
            digitalPhotoFrameCollection = data;
                    console.log(data);
            populateDeviceList(digitalPhotoFrameCollection);
        })
        .catch(error => console.error('Error fetching data:', error));*/
        
    populateDeviceList(digitalPhotoFrameCollection);
    if(selectedDeviceIndex < digitalPhotoFrameCollection.length){
        populateDeviceFields(digitalPhotoFrameCollection[selectedDeviceIndex]); 
    }

}

function populateDeviceList(digitalPhotoFrameCollection){
    
    const deviceList = document.getElementById('device-list');
    deviceList.innerHTML = '';
    
    let lastSelectedDevice = null;
    
    digitalPhotoFrameCollection.forEach((device, index) => {
 
        const listItem = document.createElement('li');
        listItem.classList.add('list-item');
        listItem.textContent = device['Name'];
        listItem.addEventListener('click', () => {
            listItem.classList.toggle('selected');
            
            if(listItem.classList.contains('selected')){
                if(lastSelectedDevice && lastSelectedDevice !== listItem){
                    lastSelectedDevice.classList.remove('last-selected');
                } 
                
                listItem.classList.add('last-selected');
                lastSelectedDevice = listItem;
                
            } else {
                if(lastSelectedDevice === listItem){
                    listItem.classList.remove('last-selected');
                    lastSelectedDevice = null;
                }
            }
            
            selectedDeviceIndex = index;
            populateDeviceFields(device);
        });
        
        deviceList.appendChild(listItem);
    });
    
    
}

function populateDeviceFields(device) {
    
    document.getElementById('device-name').value = device['Name'];
    document.getElementById('photo-update-frequency').value = device['Update Frequency'];
    document.getElementById('random-order').checked = device['Randomize'];
    
    const assignedPhotoList = document.getElementById('assigned-photo-list');
    const assignedPhotos = assignedPhotoList.getElementsByClassName('list-item');
    assignedPhotoList.innerHTML = '';
    
    let lastSelectedAssignedPhoto = null;

    device['Photo List'].forEach((photo,index) => {
        
        const listItem = document.createElement('li');
        listItem.classList.add('list-item');
        listItem.textContent = photo;
        listItem.addEventListener('click', () => {
            listItem.classList.toggle('selected');
            if(listItem.classList.contains('selected')){
                if(lastSelectedAssignedPhoto && lastSelectedAssignedPhoto !== listItem){
                    lastSelectedAssignedPhoto.classList.remove('last-selected');
                } 
                
                listItem.classList.add('last-selected');
                lastSelectedAssignedPhoto = listItem;
                
            } else {
                if(lastSelectedAssignedPhoto === listItem){
                    listItem.classList.remove('last-selected');
                    lastSelectedAssignedPhoto = null;
                }
            }
            selectedAssignedPhotoIndex = index;
            showAssignedPhotoPreview(photo);
        });
        assignedPhotoList.appendChild(listItem);
    });

}

function loadPhotos(){
    
    fetch('/get_photo_config')
        .then(response => response.json())
        .then(data => {
            digitalPhotoCollection = data;
            
            populatePhotoList(digitalPhotoCollection);
        })
        .catch(error => console.error('Error fetching data:', error));
}

function populatePhotoList(digitalPhotoCollection){
    
    const photoList = document.getElementById('photo-list');
    photoList.innerHTML = '';
    
    let lastSelectedPhoto = null;
    
    digitalPhotoCollection.forEach((photo, index) => {

        const listItem = document.createElement('li');
        listItem.classList.add('list-item');
        listItem.textContent = photo['Name'];
        listItem.addEventListener('click', () => {
            listItem.classList.toggle('selected');
            if(listItem.classList.contains('selected')){
                if(lastSelectedPhoto && lastSelectedPhoto !== listItem){
                    lastSelectedPhoto.classList.remove('last-selected');
                } 
                
                listItem.classList.add('last-selected');
                lastSelectedPhoto = listItem;
                
            } else {
                if(lastSelectedPhoto === listItem){
                    listItem.classList.remove('last-selected');
                    lastSelectedPhoto = null;
                }
            }

            
            selectedPhotoIndex = index;
            showPhotoPreview(photo);
            
            //selectedIndex = index;
            //populateDeviceFields(device);
        });
        
        photoList.appendChild(listItem);
    });
}

function showPhotoPreview(photo){
    
    
    const photoObject = document.getElementById("photo-preview");
     
    const photoName = photo["Name"];

    const newSrc = `../../photo_preview/${photoName}`;
    
    photoObject.src = newSrc;
    photoObject.style.display = 'block';
  
}

function showAssignedPhotoPreview(photo){
    
    
    const photoObject = document.getElementById("assigned-photo-preview");
     
    const photoName = photo;

    const newSrc = `../../photo_preview/${photoName}`;
    
    photoObject.src = newSrc;
    photoObject.style.display = 'block';
  
}



async function addPhotosToDevices(){
    
    let selectedPhotos = getSelectedPhotos();
    let selectedDevices = getSelectedDevices();
    
    for (let i = 0; i < selectedDevices.length; i++){
        
       let deviceIndex = selectedDevices[i];
       
       let device = digitalPhotoFrameCollection[deviceIndex]
       let existingPhotos = device['Photo List'];
       //console.log(existingPhotos);
       let uniquePhotos = selectedPhotos.filter(item => !existingPhotos.includes(item));
       //console.log(uniquePhotos);
       let combinedPhotos = existingPhotos.concat(uniquePhotos);
       //console.log(combinedPhotos);
       
       let deviceConfig = {
            "Device Index":deviceIndex,
            "Device Name": device['Name'],
            "Update Frequency": device['Update Frequency'],
            "Randomize": device['Randomize'],
            "Photo List": combinedPhotos
        };

        console.log("Saving device configuration:", deviceConfig);

        try{
            const response = await fetch('/api/save_device_config', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(deviceConfig)
            });
            const data = await response.json();
            console.log("Save response:", data);
            digitalPhotoFrameCollection = data;
        } catch (error){
            console.error('Error saving device configuration:', error)
        }
        
    }
    

    populateDeviceList(digitalPhotoFrameCollection)
    if(selectedDeviceIndex < digitalPhotoFrameCollection.length){
        populateDeviceFields(digitalPhotoFrameCollection[selectedDeviceIndex]); 
    }
}

async function removePhotosFromDevice(){
    
    let selectedAssignedPhotos = getSelectedAssignedPhotos();
    console.log(selectedAssignedPhotos);
    let device = digitalPhotoFrameCollection[selectedDeviceIndex];
    let assignedPhotos = device['Photo List'];
    console.log(assignedPhotos);
    let truncatedPhotos = assignedPhotos.filter(item => !selectedAssignedPhotos.includes(item));
    console.log(truncatedPhotos);
    
    let deviceConfig = {
        "Device Index":selectedDeviceIndex,
        "Device Name": device['Name'],
        "Update Frequency": device['Update Frequency'],
        "Randomize": device['Randomize'],
        "Photo List": truncatedPhotos
    };

    console.log("Saving device configuration:", deviceConfig);

    try{
        const response = await fetch('/api/save_device_config', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(deviceConfig)
        });
        const data = await response.json();
        console.log("Save response:", data);
        digitalPhotoFrameCollection = data;
    } catch (error){
        console.error('Error saving device configuration:', error)
    }
    
    populateDeviceList(digitalPhotoFrameCollection)
    if(selectedDeviceIndex < digitalPhotoFrameCollection.length){
        populateDeviceFields(digitalPhotoFrameCollection[selectedDeviceIndex]); 
    }
    
    
    
}



function getSelectedPhotos() {
    
    const photoList = document.getElementById('photo-list');
    const photos = photoList.getElementsByClassName('list-item');
    const selectedPhotos = [];
    Array.from(photos).forEach(photo => {
        if (photo.classList.contains('selected')) {
            selectedPhotos.push(photo.textContent);
        }
    });
    
    return selectedPhotos;
 
}

function getSelectedAssignedPhotos() {
    
    const assignedPhotoList = document.getElementById('assigned-photo-list');
    const photos = assignedPhotoList.getElementsByClassName('list-item');
    const selectedPhotos = [];
    Array.from(photos).forEach(photo => {
        if (photo.classList.contains('selected')) {
            selectedPhotos.push(photo.textContent);
        }
    });
    
    return selectedPhotos;
}

function getSelectedDevices() {
    
    const deviceList = document.getElementById('device-list');
    const devices = deviceList.getElementsByClassName('list-item');
    const selectedIndices = [];
    Array.from(devices).forEach((device, index) => {
        if (device.classList.contains('selected')) {
            selectedIndices.push(index);
        }
    });
    
    return selectedIndices;
 
}

// End Dan's code


/**
 * Save the device configuration to the server
 */
async function saveDevice() {
    
    let deviceName = document.getElementById('device-name').value;
    let photoUpdateFrequency = document.getElementById('photo-update-frequency').value;
    let randomOrder = document.getElementById('random-order').checked;
    
    const assignedPhotoList = document.getElementById('assigned-photo-list');
    const photosInList = assignedPhotoList.getElementsByClassName('list-item');
    const assignedPhotos = []
    Array.from(photosInList).forEach(photo => {
        assignedPhotos.push(photo.textContent);
    });
    
    console.log(assignedPhotos);
    
    

    let deviceConfig = {
        "Device Index":selectedDeviceIndex,
        "Device Name": deviceName,
        "Update Frequency": photoUpdateFrequency,
        "Randomize": randomOrder,
        "Photo List": assignedPhotos
    };

    console.log("Saving device configuration:", deviceConfig);

    try{
        const response = await fetch('/api/save_device_config', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(deviceConfig)
        });
        const data = await response.json();
        console.log("Save response:", data);
        digitalPhotoFrameCollection = data;
        /*if (data.success) {
            alert('Device configuration saved successfully');
            digitalPhotoFrameCollection = data;
        }*/
    } catch (error){
        console.error('Error saving device configuration:', error)
    }

    populateDeviceList(digitalPhotoFrameCollection)
    if(selectedDeviceIndex < digitalPhotoFrameCollection.length){
        populateDeviceFields(digitalPhotoFrameCollection[selectedDeviceIndex]); 
    }

}

/**
 * Add selected photos to selected devices
 */
function addToDevices() {
    let selectedPhotos = Array.from(document.querySelectorAll('input[name="photo"]:checked')).map(input => input.value);
    let selectedDevices = Array.from(document.querySelectorAll('input[name="device"]:checked')).map(input => input.value);

    if (selectedPhotos.length === 0 || selectedDevices.length === 0) {
        alert("Please select at least one photo and one device.");
        return;
    }

    console.log("Adding Photos to Devices", selectedPhotos, selectedDevices);

    fetch('/api/add_photos_to_devices', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            photo_ids: selectedPhotos,
            device_ids: selectedDevices
        })
    })
        .then(response => response.json())
        .then(data => {
            console.log("Add photos response:", data);
            if (data.success) {
                alert('Photos successfully added to devices');
            }
        })
        .catch(error => console.error('Error adding photos to devices:', error));
}



/**
 * Move a selected photo up or down in the list
 * @param {string} direction - The direction to move the photo ('up' or 'down')
 */
async function movePhoto(direction) {
         
    
    const assignedPhotoList = document.getElementById('assigned-photo-list');
    const photos = assignedPhotoList.getElementsByClassName('list-item');
    let selectedPhotoIndex = -1;
    Array.from(photos).forEach((photo, index) => {
        if (photo.classList.contains('last-selected')) {
            selectedPhotoIndex = index;
        }
    });
    
    console.log(selectedPhotoIndex);
    
    let device = digitalPhotoFrameCollection[selectedDeviceIndex];
    let assignedPhotos = device['Photo List'];
    console.log(assignedPhotos);
    
    if(
        selectedPhotoIndex === -1 || 
        (selectedPhotoIndex === 0 && direction === 'up') ||
        (selectedPhotoIndex === assignedPhotos.length-1 && direction === 'down')){
        return;
    }

    let newIndex = direction === 'up' ? selectedPhotoIndex -1 : selectedPhotoIndex +1;
    let selectedPhoto = assignedPhotos[selectedPhotoIndex];
    console.log(selectedPhotoIndex);
    console.log(assignedPhotos[selectedPhotoIndex]);
    
    assignedPhotos.splice(selectedPhotoIndex, 1);
    assignedPhotos.splice(newIndex, 0, selectedPhoto);
    console.log(assignedPhotos);
    
    assignedPhotoList.innerHTML = '';
    
    let lastSelectedAssignedPhoto = null;

    assignedPhotos.forEach((photo,index) => {
        
        const listItem = document.createElement('li');
        listItem.classList.add('list-item');
        listItem.textContent = photo;
        listItem.addEventListener('click', () => {
            listItem.classList.toggle('selected');
            if(listItem.classList.contains('selected')){
                if(lastSelectedAssignedPhoto && lastSelectedAssignedPhoto !== listItem){
                    lastSelectedAssignedPhoto.classList.remove('last-selected');
                } 
                
                listItem.classList.add('last-selected');
                lastSelectedAssignedPhoto = listItem;
                
            } else {
                if(lastSelectedAssignedPhoto === listItem){
                    listItem.classList.remove('last-selected');
                    lastSelectedAssignedPhoto = null;
                }
            }
            selectedAssignedPhotoIndex = index;
            showAssignedPhotoPreview(photo);
        });
        assignedPhotoList.appendChild(listItem);
        if(index===newIndex){
            listItem.classList.add('selected');
            listItem.classList.add('last-selected');
        }
    });
    
}
 

// Event listeners for buttons
document.querySelector('.add-to-devices').addEventListener('click', addPhotosToDevices);
document.querySelector('.save-config').addEventListener('click', saveDevice);
document.querySelector('.move-up').addEventListener('click', () => movePhoto('up'));
document.querySelector('.move-down').addEventListener('click', () => movePhoto('down'));
document.querySelector('.remove').addEventListener('click', removePhotosFromDevice);


################################################################################
File: ./web/templates/device_manager.html
<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Meta tags for character encoding and viewport configuration -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- Link to Google Fonts for 'Inter' font family -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;800&display=swap">
    
    <!-- Link to external CSS file for styling -->
    <link rel="stylesheet" href="{{ url_for('static', filename='device_manager.css') }}">
    
    <!-- Page title -->
    <title>FrameCast Digital Photo Frame Network</title>
</head>
<body>
    <!-- Navbar section for navigation -->
    <header class="navbar">
        <a href="/device_manager" class="navbar-item highlight">DEVICE MANAGER</a>
        <a href="/device_editor" class="navbar-item">DEVICE EDITOR</a>
        <a href="/photo_editor" class="navbar-item">PHOTO EDITOR</a>
    </header>

    <!-- Main content area -->
    <main class="main-content">
        <!-- Discovered devices section -->
        <section class="devices-section">
            <h2 class="section-title">DISCOVERED DEVICES</h2>
            <div id="discovered-devices" class="device-list"></div>
            <button class="action-button" onclick="findNewDevices()">FIND NEW DEVICES</button>
            <button class="action-button" onclick="inviteToNetwork()">INVITE TO NETWORK</button>
        </section>

        <!-- Networked devices section -->
        <section class="devices-section">
            <button class="action-button" onclick="refreshDevices()">REFRESH</button>
            <button class="action-button" onclick="deleteDevices()">DELETE DEVICE</button>
            <h2 class="section-title">NETWORKED DEVICES</h2>
            <table id="data-table">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>IP Address</th>
                        <th>Connected</th>              
                </thead>
                <tbody>
                </tbody>
            </table>
        </section>
    </main>

    <!-- Link to external JavaScript file for interactivity -->
    <script src="{{ url_for('static', filename='device_manager.js') }}"></script>
</body>
</html>


################################################################################
File: ./web/templates/photo_editor.html
<!DOCTYPE html>
<html lang="en">

<head>
    <!-- Meta tags for character encoding and viewport configuration -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- Link to Google Fonts for 'Inter' font family -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;800&display=swap">
    
    <!-- Link to external CSS file for styling -->
    <link rel="stylesheet" href="{{ url_for('static', filename='photo_editor.css') }}">
    
    <!-- Page title -->
    <title>Photo Editor</title>
</head>

<body>
    <!-- Navbar section for navigation -->
    <header class="navbar">
        <a href="/device_manager" class="navbar-item">DEVICE MANAGER</a>
        <a href="/device_editor" class="navbar-item">DEVICE EDITOR</a>
        <a href="/photo_editor" class="navbar-item highlight">PHOTO EDITOR</a>
    </header>

    <!-- Main content area -->
    <main class="main-content">
        <!-- Photo list section -->
        <section class="photo-list-section">
            <h2 class="section-title">PHOTOS</h2>
            <div class="photo-list" id="photo-list">
            </div>
            <form id="uploadForm" action="/api/upload_photos" method="post" enctype="multipart/form-data">
                <input type="file" name="files[]" id="fileInput" accept=".jpg" multiple>
                <label for="fileInput" class="action-button">UPLOAD PHOTOS</button>
            </form>
            <button class="action-button" onclick="deletePhotos()">DELETE SELECTED PHOTOS</button>
        </section>
        
        <!-- Photo display section -->
        <section class="photo-display-panel">
            <div class="photo-controls">
                <button class="action-button scale" id="scalePhoto">SCALE</button>
                <input type="number" class="scale-input" value="100" min="10" max="100" id="photoScaleValue">
                <span>%</span>
                <button class="action-button save">SAVE</button>
            </div>
            <h2 class="section-title">Photo Display</h2>
            <div class="photo-container">
                <img src="" alt="Preview Image" class="preview-image" id="previewImage">
                <div class="window-box" id="windowBox"></div>
            </div>
        </section>
    </main>

    <!-- Link to external JavaScript file for interactivity -->
    <script src="{{ url_for('static', filename='photo_editor.js') }}"></script>
</body>

</html>


################################################################################
File: ./web/templates/device_editor.html
<!DOCTYPE html>
<html lang="en">

<head>
    <!-- Meta tags for character encoding and viewport configuration -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- Link to Google Fonts for 'Inter' font family -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;800&display=swap">
    
    <!-- Link to external CSS file for styling -->
    <link rel="stylesheet" href="{{ url_for('static', filename='device_editor.css') }}">
    
    <!-- Page title -->
    <title>Device Editor</title>
</head>

<body>
    <!-- Navbar section for navigation -->
    <header class="navbar">
        <a href="/device_manager" class="navbar-item">DEVICE MANAGER</a>
        <a href="/device_editor" class="navbar-item highlight">DEVICE EDITOR</a>
        <a href="/photo_editor" class="navbar-item">PHOTO EDITOR</a>
    </header>

    <!-- Main content area -->
    <main class="main-content">
        <!-- Photo list section -->
        <section class="photo-list-section">
            <h2 class="section-title">PHOTOS</h2>
            <div class="photo-list" id="photo-list">
                <!-- Photos will be dynamically populated here -->
            </div>
            <div class="preview">
                <h3>PREVIEW</h3>
                <img src="" alt="Preview" class="preview-image" id="photo-preview">
            </div>
        </section>
        
        <!-- Button to add photos to devices -->
        <button class="action-button add-to-devices">ADD TO DEVICES</button>
        
        <!-- Device list section -->
        <section class="device-list-section">
            <h2 class="section-title">DEVICES</h2>
            <div class="device-list" id="device-list">
                <!-- Devices will be dynamically populated here -->
            </div>
        </section>
        
        <!-- Device configuration panel -->
        <section class="device-config-pane">
            <h2 class="section-title">DEVICE CONFIGURATION</h2>
            <div class="config-item">
                <label for="device-name">Device Name:</label>
                <input type="text" id="device-name" name="device-name">
            </div>
            <div class="config-item">
                <label for="photo-update-frequency">Photo Update Frequency (seconds):</label>
                <input type="number" id="photo-update-frequency" name="photo-update-frequency" min="0" max="999">
            </div>
            <div class="config-item">
                <label for="random-order">Randomize Order:</label>
                <input type="checkbox" id="random-order" name="random-order">
            </div>
            <div class="config-item">
                <h3>ASSIGNED PHOTOS</h3>
                <div class="assigned-photo-list" id="assigned-photo-list">
                    <!-- Paired photos will be dynamically populated here -->
                </div>
                <div class="button-group">
                    <button class="action-button move-up">MOVE UP</button>
                    <button class="action-button move-down">MOVE DOWN</button>
                    <button class="action-button remove">REMOVE</button>
                </div>
                <div class="preview">
                    <img src="" alt="Preview" class="preview-image" id="assigned-photo-preview">
                </div>
            </div>
            <button class="action-button save-config">SAVE DEVICE CONFIGURATION</button>
        </section>
    </main>

    <!-- Link to external JavaScript file for interactivity -->
    <script src="{{ url_for('static', filename='device_editor.js') }}"></script>
</body>

</html>


################################################################################
File: ./agent/run.py
import time
import threading
from controller.frame_controller import start_frame_controller
from web.web_server import start_web_server
import pyautogui

def main():
	
	web_server_thread = threading.Thread(target=start_web_server)
	web_server_thread.daemon = True
	web_server_thread.start()
	
	start_frame_controller()
	
	'''try:
		while True:
			time.sleep(1)
			pyautogui.click(1000,500)
	except KeyboardInterrupt:
		print("Application closing...")'''
		
if __name__ == '__main__':
	main()


	


################################################################################
File: ./agent/code_distributor.py
import time
import requests
import paramiko
from scp import SCPClient
import os

class SCPConnection:
    def __init__(self, hostname,username,password):
        self.hostname = hostname
        self.username = username
        self.password = password
        self.ssh = None
        self.scp = None
        self.connect()
    
    def connect(self):
        self.ssh = paramiko.SSHClient()
        self.ssh.load_system_host_keys()
        self.ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        self.ssh.connect(self.hostname, username=self.username, password=self.password, compress=True)
        self.scp = SCPClient(self.ssh.get_transport())
        
    def close(self):
        if self.scp:
            self.scp.close()
        if self.ssh:
            self.ssh.close()
            
    def send_file(self, local_path, remote_path):
        try:
            self.scp.put(local_path, remote_path)
            return True
        except Exception as e:
            print(f"Failed to establish SCP connection: {e}")
            return False
    
    def get_file(self, remote_path, local_path):
        try:
            self.scp.get(remote_path,local_path)
            print(f"File {remote_path} copied to {local_path}")
        except Exception as e:
            print(f"Failed to establish SCP connection: {e}")
            
    def make_directory(self, directory):
        stdin, stdout, stderr = self.ssh.exec_command(f'mkdir -p {directory}')
        exit_status = stdout.channel.recv_exit_status()
        print(f"Stdout: {stdout.read().decode()}")
        if exit_status != 0:
            print(f"Error creating directory {directory}: {stderr.read().decode()}")


remote_framecast_dir = "/home/rpi0w/Desktop/FrameCast"
local_framecast_dir = os.path.dirname(__file__)
#agent_controller_dir = os.path.join(agent_framecast_dir,'..','controller')
#principal_controller_dir = os.path.join(principal_framecast_dir,'..','controller')
#agent_wireless_dir = os.path.join(agent_dir,'..','wireless')
#principal_wireless_dir = os.path.join(principal_dir,'..','wireless')
#web_dir = os.path.join(agent_dir,'..','web')
#top_dir = os.path.join(current_dir,'..')

files = [
    #'run.py',
    #'controller/frame_controller.py'
    #'controller/logo.jpg',
    'wireless/bluetooth_connection.py'
    #'wireless/wifi_connection.py',
    #'web/web_server.py'

]

directories = [
    'controller',
    'controller/displayed_photo',
    'wireless'
    'web'
]

def distribute_files():
    
    for filepath in files:
        remote_filepath = os.path.join(remote_framecast_dir,filepath)
        local_filepath = os.path.join(local_framecast_dir,filepath)
        print(f"Sending local file {local_filepath} to {remote_filepath}")
        scp_connection.send_file(local_filepath, remote_filepath)
    
    
def retrieve_files():
    
    for filepath in files:
        remote_filepath = os.path.join(remote_framecast_dir,filepath)
        local_filepath = os.path.join(local_framecast_dir,filepath)
        scp_connection.get_file(remote_filepath,local_filepath)

if __name__ == '__main__':
    
    scp_connection = SCPConnection("172.20.10.9","rpi0w","raspberry")
    scp_connection.connect()
    distribute_files()
    scp_connection.close()
    

            
        





################################################################################
File: ./agent/web/web_server.py
from flask import Flask, jsonify

app = Flask(__name__)

@app.route('/heartbeat',methods=['GET'])
def heartbeat():
	return jsonify(status="success",message="Connection successful"), 200
	
def start_web_server():
	print("Starting web server...")
	app.run(host='0.0.0.0', port=5000)

if __name__ == '__main__':
	start_web_server()


################################################################################
File: ./agent/controller/frame_controller.py
import time
import os
import tkinter as tk
from PIL import Image, ImageTk, ImageDraw, ImageFont
from threading import Thread
import queue
import RPi.GPIO as GPIO
import subprocess
import socket
import pyautogui
import re

current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
wireless_dir = os.path.join(parent_dir,'wireless')
bluetooth_script = os.path.join(wireless_dir,'bluetooth_connection.py')
wireless_script = os.path.join(wireless_dir,'wifi_connection.py')
next_file_path = os.path.join(current_dir,'displayed_photo','next.jpg')
current_file_path = os.path.join(current_dir,'displayed_photo','current.jpg')
init_file_path = os.path.join(current_dir,'logo.jpg')
hostname_file_path = os.path.join(current_dir,'hostname_display.jpg')

BUTTON_PIN = 4

GPIO.setmode(GPIO.BCM)
GPIO.setup(BUTTON_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)

pyautogui.FAILSAFE = False
fullscreen = False

def get_hostname():
    
    try:
        return socket.gethostname()
    except Exception as e:
        print(f"Error getting hostname: {e}")
        return None    

def create_hostname_display():
    
    hostname = get_hostname()
    if hostname:
        message = hostname
    else:
        message = "Not Available"
    font_path = "/user/share/fonts/truetype/dejavu/DejaVuSans.ttf"
    font_size = 40
    hostname_image = Image.new('RGB', (1024,600), color='black')
    width, height = hostname_image.size
    hostname_draw = ImageDraw.Draw(hostname_image)
    font = ImageFont.truetype(font_path,font_size)
    text_bbox = hostname_draw.textbbox((0,0),message,font=font)
    #text_width = text_bbox[2] - text_bbox[0]
    #text_height = text_bbox[3] - text_bbox[1]
    #text_x = (width - text_width) // 2
    #text_y = (height - text_height) // 2
    hostname_draw.text((10,10), message, font = font, fill='white')
    hostname_image.save(hostname_file_path)

def run_command(command):
    result = subprocess.run(command,shell=True,capture_output=True,text=True)
    if result.returncode != 0:
        print(f"Error running command: {command}\n{result.stderr}")
    else:
        print(f"Command successful: {command}\n{result.stdout}")
    return result

def run_wireless_script(ssid, psk):
    result = subprocess.run(["sudo","python3",wireless_script,ssid,psk],capture_output=True,text=True)
    if result.returncode != 0:
        print(f"Error running wireless script:\n{result.stderr}")
    else:
        print(f"Wireless script successful:\n{result.stdout}")
    return result


def enter_bluetooth_discovery_mode():
    
    run_command("sudo btmgmt io-cap 3")
    run_command("sudo hciconfig hci0 piscan")
    return run_command(f"sudo python3 {bluetooth_script}")

def connect_to_wifi_network(result):
       
    print(f"Result of bluetooth_script: \n{result}")
    ssid = None
    psk = None
    for line in result.stdout.splitlines():
        match = re.match(r"WIFI: (.+) (\S+)$", line)
        if match:
            ssid = match.group(1)
            psk = match.group(2)
            print(f"SSID: {ssid}")
            print(f"PSK: {psk}")
            break
    
    if ssid is not None and psk is not None:
        run_wireless_script(ssid,psk)
    else:
        print("Error getting ssid and psk")
    run_command("sudo hciconfig hci0 noscan")

   
def frame_control(q):
    
    previous_state = GPIO.HIGH
    time.sleep(5)
           
    while True:
        current_state = GPIO.input(BUTTON_PIN)
        if previous_state == GPIO.HIGH and current_state == GPIO.LOW:
            q.put(hostname_file_path)
            result = enter_bluetooth_discovery_mode()
            connect_to_wifi_network(result)
            q.put(init_file_path)
        if os.path.exists(next_file_path):            
            try:
                if os.path.exists(current_file_path):
                    os.remove(current_file_path)
                os.rename(next_file_path,current_file_path)
                q.put(current_file_path)
            except Exception as e:
                print(f"An error occurred: {e}")

        previous_state = current_state
        time.sleep(1)
    
def update_display(image_label, q):
    
    if fullscreen:
        pyautogui.click(50,500)
    
    try:
        image_path = q.get_nowait()
        if os.path.exists(image_path):
            image = Image.open(image_path)
            display = ImageTk.PhotoImage(image)
            image_label.config(image=display)
            image_label.image = display
    except queue.Empty:
        pass
    
    image_label.after(1000, update_display, image_label, q)
  
def start_frame_controller():
           
    print("Starting frame controller server...")
    root = tk.Tk()
    root.geometry("1024x600")
    
    create_hostname_display()
    
    init_display_environment(root)
    
    image_label = tk.Label(root)
    image_label.pack(fill=tk.BOTH, expand=True)
    
    q = queue.Queue(maxsize=1)
    q.put(init_file_path)
        
    update_thread = Thread(target=frame_control,args=(q,),daemon=True)
    update_thread.start()
        
    update_display(image_label, q)
    
    root.mainloop()

def init_display_environment(root=None):
    root.attributes("-fullscreen",True)
    global fullscreen
    fullscreen = True
    root.config(cursor="none")
    root.bind("<Escape>",lambda event: revert_display_environment(event,root))
    #os.system("lxpanelctl exit")

def revert_display_environment(event=None,root=None):
    root.attributes("-fullscreen",False)
    global fullscreen
    fullscreen = False
    root.config(cursor="")
    #os.system("lxpanelctl restart")

if __name__ == "__main__":
    start_frame_controller()
    

    
    


################################################################################
File: ./agent/wireless/wifi_connection.py
import os
import subprocess
import sys

def main(args):
	if len(args) != 2:
		print("Error: Expected two arguments")
		exit(1)
	if os.geteuid() != 0:
		print("Error: This script must be run as root")
		exit(1)

	ssid = args[0]
	psk = args[1]
	
	print(f"Received arguments: {ssid} and {psk}")
	
	# Run command to connect to wifi network
	try:
			print("Connecting...")
			subprocess.run(['nmcli', 'dev', 'wifi', 'connect', ssid, 'password', psk], check=True)
			#client_socket.send("OK")

	except subprocess.CalledProcessError as e:
			print('Failed to connect')
			#client_socket.send("Failed to connect")
			exit(1)

	#client_socket.close()
	#server_socket.close()

	# Restart avahi-daemon just in case to make sure rpi hostname is advertised so enumerate_wifi_devices can read it
	subprocess.run(['sudo', 'systemctl', 'restart', 'avahi-daemon'], check=True)

if __name__ == '__main__':
	main(sys.argv[1:])






################################################################################
File: ./agent/wireless/bluetooth_connection.py
import bluetooth
import os
import subprocess
from base64 import b64decode, b64encode
from Cryptodome.Cipher import AES
from Cryptodome.Util.Padding import unpad

def decrypt(encrypted_text, key):
	
	encrypted_bytes = b64decode(encrypted_text)
	key_bytes = b64decode(key)
	
	cipher = AES.new(key_bytes, AES.MODE_ECB)
	
	decrypted_bytes = unpad(cipher.decrypt(encrypted_bytes), AES.block_size)
	
	return decrypted_bytes.decode('utf-8')

if os.geteuid() != 0:
	print("This script must be run as root")
	exit(1)

# Set socket to listen for bluetooth connection from app or web portal
server_socket = bluetooth.BluetoothSocket(bluetooth.RFCOMM)

port = 1
server_socket.bind(("", port))

server_socket.listen(1)
port = server_socket.getsockname()[1]

server_socket.settimeout(180)

# Advertise service with UUID for bluetooth connection from app
bluetooth.advertise_service(server_socket, "Pi4Server",
							service_id = "00001101-0000-1000-8000-00805F9B34FB",
							service_classes = ["00001101-0000-1000-8000-00805F9B34FB", bluetooth.SERIAL_PORT_CLASS],
							profiles = [bluetooth.SERIAL_PORT_PROFILE])
							
print("Bluetooth service advertised. Waiting for connection...")							

try:
	# Get socket and address from device trying to connect
	client_socket, address = server_socket.accept()
except bluetooth.BluetoothError as e:
	print("No connection was made within the timeout period")
	server_socket.close()
	exit(1)


ssid = None
psk = None
encrypted_password = None
secret_key = None

try:

	while True:
		data = client_socket.recv(1024).decode('utf-8')
		if len(data) == 0:
			exit
		print(f"Recieved: {data}")
		recieved_data = data.split("/n")
		print(f"Recieved: {recieved_data}")
		
		ssid = recieved_data[0]
		print("SSID: ", ssid)
		encrypted_password = recieved_data[1]
		secret_key = recieved_data[2]
		
		print(encrypted_password)
		print(secret_key)
		if (ssid and encrypted_password and secret_key):
			break

except OSError:
	pass
	
psk = decrypt(encrypted_password, secret_key)
print("Decrypted password: ", psk)

print(f"WIFI: {ssid} {psk}")

client_socket.close()
server_socket.close()





################################################################################
File: ./controller/frame_controller.py
import time
import os
import tkinter as tk
from PIL import Image, ImageTk, ImageDraw, ImageFont
from threading import Thread
import queue
import RPi.GPIO as GPIO
import subprocess
import socket
import pyautogui
import re

current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
wireless_dir = os.path.join(parent_dir,'wireless')
bluetooth_script = os.path.join(wireless_dir,'bluetooth_connection.py')
wireless_script = os.path.join(wireless_dir,'wifi_connection.py')
next_file_path = os.path.join(current_dir,'displayed_photo','next.jpg')
current_file_path = os.path.join(current_dir,'displayed_photo','current.jpg')
init_file_path = os.path.join(current_dir,'logo.jpg')
hostname_file_path = os.path.join(current_dir,'hostname_display.jpg')

BUTTON_PIN = 4

GPIO.setmode(GPIO.BCM)
GPIO.setup(BUTTON_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)

pyautogui.FAILSAFE = False
fullscreen = False

def get_hostname():
    
    try:
        return socket.gethostname()
    except Exception as e:
        print(f"Error getting hostname: {e}")
        return None    

def create_hostname_display():
    
    hostname = get_hostname()
    if hostname:
        message = hostname
    else:
        message = "Not Available"
    font_path = "/user/share/fonts/truetype/dejavu/DejaVuSans.ttf"
    font_size = 40
    hostname_image = Image.new('RGB', (1024,600), color='black')
    width, height = hostname_image.size
    hostname_draw = ImageDraw.Draw(hostname_image)
    font = ImageFont.truetype(font_path,font_size)
    text_bbox = hostname_draw.textbbox((0,0),message,font=font)
    #text_width = text_bbox[2] - text_bbox[0]
    #text_height = text_bbox[3] - text_bbox[1]
    #text_x = (width - text_width) // 2
    #text_y = (height - text_height) // 2
    hostname_draw.text((10,10), message, font = font, fill='white')
    hostname_image.save(hostname_file_path)

def run_command(command):
    result = subprocess.run(command,shell=True,capture_output=True,text=True)
    if result.returncode != 0:
        print(f"Error running command: {command}\n{result.stderr}")
    else:
        print(f"Command successful: {command}\n{result.stdout}")
    return result

def run_wireless_script(ssid, psk):
    result = subprocess.run(["sudo","python3",wireless_script,ssid,psk],capture_output=True,text=True)
    if result.returncode != 0:
        print(f"Error running wireless script:\n{result.stderr}")
    else:
        print(f"Wireless script successful:\n{result.stdout}")
    return result


def enter_bluetooth_discovery_mode():
    
    run_command("sudo btmgmt io-cap 3")
    run_command("sudo hciconfig hci0 piscan")
    return run_command(f"sudo python3 {bluetooth_script}")

def connect_to_wifi_network(result):
       
    print(f"Result of bluetooth_script: \n{result}")
    ssid = None
    psk = None
    for line in result.stdout.splitlines():
        match = re.match(r"WIFI: (.+) (\S+)$", line)
        if match:
            ssid = match.group(1)
            psk = match.group(2)
            print(f"SSID: {ssid}")
            print(f"PSK: {psk}")
            break
    
    if ssid is not None and psk is not None:
        run_wireless_script(ssid,psk)
    else:
        print("Error getting ssid and psk")
    run_command("sudo hciconfig hci0 noscan")

   
def frame_control(q):
    
    previous_state = GPIO.HIGH
    time.sleep(5)
           
    while True:
        current_state = GPIO.input(BUTTON_PIN)
        if previous_state == GPIO.HIGH and current_state == GPIO.LOW:
            q.put(hostname_file_path)
            result = enter_bluetooth_discovery_mode()
            connect_to_wifi_network(result)
            q.put(init_file_path)
        if os.path.exists(next_file_path):            
            try:
                if os.path.exists(current_file_path):
                    os.remove(current_file_path)
                os.rename(next_file_path,current_file_path)
                q.put(current_file_path)
            except Exception as e:
                print(f"An error occurred: {e}")

        previous_state = current_state
        time.sleep(1)
    
def update_display(image_label, q):
    
    if fullscreen:
        pyautogui.click(50,500)
    
    try:
        image_path = q.get_nowait()
        if os.path.exists(image_path):
            image = Image.open(image_path)
            display = ImageTk.PhotoImage(image)
            image_label.config(image=display)
            image_label.image = display
    except queue.Empty:
        pass
    
    image_label.after(1000, update_display, image_label, q)
  
def start_frame_controller():
           
    print("Starting frame controller server...")
    root = tk.Tk()
    root.geometry("1024x600")
    
    create_hostname_display()
    
    init_display_environment(root)
    
    image_label = tk.Label(root)
    image_label.pack(fill=tk.BOTH, expand=True)
    
    q = queue.Queue(maxsize=1)
    q.put(init_file_path)
        
    update_thread = Thread(target=frame_control,args=(q,),daemon=True)
    update_thread.start()
        
    update_display(image_label, q)
    
    root.mainloop()

def init_display_environment(root=None):
    root.attributes("-fullscreen",True)
    global fullscreen
    fullscreen = True
    root.config(cursor="none")
    root.bind("<Escape>",lambda event: revert_display_environment(event,root))
    #os.system("lxpanelctl exit")

def revert_display_environment(event=None,root=None):
    root.attributes("-fullscreen",False)
    global fullscreen
    fullscreen = False
    root.config(cursor="")
    #os.system("lxpanelctl restart")

if __name__ == "__main__":
    start_frame_controller()
    

    
    


################################################################################
File: ./controller/frame_controller_original.py
import time
import os
import tkinter as tk
from PIL import Image, ImageTk, ImageDraw, ImageFont
from threading import Thread
import queue
import RPi.GPIO as GPIO
import subprocess
import socket

current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
wireless_dir = os.path.join(parent_dir,'wireless')
bluetooth_script = os.path.join(wireless_dir,'bluetoothsocket.py')
next_file_path = os.path.join(current_dir,'displayed_photo','next.jpg')
current_file_path = os.path.join(current_dir,'displayed_photo','current.jpg')
init_file_path = os.path.join(current_dir,'logo.jpg')
hostname_file_path = os.path.join(current_dir,'hostname_display.jpg')

BUTTON_PIN = 16

GPIO.setmode(GPIO.BCM)
GPIO.setup(BUTTON_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)

def get_hostname():
    
    try:
        return socket.gethostname()
    except Exception as e:
        print(f"Error getting hostname: {e}")
        return None    

def create_hostname_display():
    
    hostname = get_hostname()
    if hostname:
        message = hostname
    else:
        message = "Not Available"
    font_path = "/user/share/fonts/truetype/dejavu/DejaVuSans.ttf"
    font_size = 40
    hostname_image = Image.new('RGB', (1024,600), color='black')
    width, height = hostname_image.size
    hostname_draw = ImageDraw.Draw(hostname_image)
    font = ImageFont.truetype(font_path,font_size)
    text_bbox = hostname_draw.textbbox((0,0),message,font=font)
    #text_width = text_bbox[2] - text_bbox[0]
    #text_height = text_bbox[3] - text_bbox[1]
    #text_x = (width - text_width) // 2
    #text_y = (height - text_height) // 2
    hostname_draw.text((10,10), message, font = font, fill='white')
    hostname_image.save(hostname_file_path)

def run_command(command):
    result = subprocess.run(command,shell=True,capture_output=True,text=True)
    if result.returncode != 0:
        print(f"Error running command: {command}\n{result.stderr}")
    else:
        print(f"Command successful: {command}\n{result.stdout}")


def enter_bluetooth_discovery_mode():
    
    run_command("sudo hciconfig hci0 piscan")
    run_command(f"sudo python3 {bluetooth_script}")
    run_command("sudo hciconfig hci0 noscan")

   
def frame_control(q):
    
    previous_state = GPIO.HIGH
    time.sleep(5)
           
    while True:
        current_state = GPIO.input(BUTTON_PIN)
        if previous_state == GPIO.HIGH and current_state == GPIO.LOW:
            q.put(hostname_file_path)
            enter_bluetooth_discovery_mode()
            q.put(init_file_path)		
        if os.path.exists(next_file_path):            
            try:
                if os.path.exists(current_file_path):
                    os.remove(current_file_path)
                os.rename(next_file_path,current_file_path)
                q.put(current_file_path)
            except Exception as e:
                print(f"An error occurred: {e}")

        previous_state = current_state
        time.sleep(1)
    
def update_display(image_label, q):
    
    try:
        image_path = q.get_nowait()
        if os.path.exists(image_path):
            image = Image.open(image_path)
            display = ImageTk.PhotoImage(image)
            image_label.config(image=display)
            image_label.image = display
    except queue.Empty:
        pass
    
    image_label.after(1000, update_display, image_label, q)
  
def start_frame_controller():
           
    root = tk.Tk()
    root.geometry("1024x600")
    
    create_hostname_display()
    
    #init_display_environment(root)
    
    image_label = tk.Label(root)
    image_label.pack(fill=tk.BOTH, expand=True)
    
    q = queue.Queue(maxsize=1)
    q.put(init_file_path)
        
    update_thread = Thread(target=frame_control,args=(q,),daemon=True)
    update_thread.start()
        
    update_display(image_label, q)
    
    root.mainloop()

def init_display_environment(root=None):
    root.attributes("-fullscreen",True)
    root.config(cursor="none")
    root.bind("<Escape>",lambda event: revert_display_environment(event,root))

def revert_display_environment(event=None,root=None):
    root.attributes("-fullscreen",False)
    root.config(cursor="")

if __name__ == "__main__":
    start_frame_controller()
    

    
    


################################################################################
File: ./__tests__/photo-editor-app.test.js
const puppeteer = require('puppeteer');

describe('Photo Editor App', () => {
    let browser;
    let page;

    // Before all tests, launch the browser and create a new page
    beforeAll(async () => {
        browser = await puppeteer.launch({
            headless: true, // Run in headless mode
            args: ['--no-sandbox', '--disable-setuid-sandbox'], // Required for some environments
            executablePath: '/usr/bin/chromium-browser'  // Adjust this path if necessary
        });
        page = await browser.newPage();
    });

    // Before each test, reset the state and navigate to the photo editor page
    beforeEach(async () => {
        await page.goto('http://localhost:5000/reset'); // Endpoint to reset state
        await page.goto('http://localhost:5000/photo-editor'); // Navigate to the photo editor
    });

    // After all tests, close the browser
    afterAll(async () => {
        if (browser) {
            await browser.close();
        }
    });

    // Test to check if all photos are fetched on load
    test('should fetch all photos on load', async () => {
        await page.waitForSelector('.photo-list'); // Wait for the photo list to be rendered
        const photos = await page.evaluate(() => {
            // Extract the text content of each photo label
            return Array.from(document.querySelectorAll('.photo-list label')).map(label => label.textContent.trim());
        });
        console.log('Fetched photos:', photos);
        expect(photos).toContain('Photo1');
        expect(photos).toContain('Photo2');
    });

    // Test to check if a new photo can be uploaded
    test('should upload a new photo', async () => {
        // Get the initial list of photos
        const initialPhotos = await page.evaluate(() => {
            return Array.from(document.querySelectorAll('.photo-list label')).map(label => label.textContent.trim());
        });
        console.log('Initial photos:', initialPhotos);
        expect(initialPhotos).not.toContain('New Photo');

        // Click the upload button
        await page.click('.upload-button');
        console.log('Clicked upload button');

        // Wait for the simulated upload to complete
        await page.waitForSelector('.photo-list label');

        // Get the updated list of photos
        const photosAfterUpload = await page.evaluate(() => {
            return Array.from(document.querySelectorAll('.photo-list label')).map(label => label.textContent.trim());
        });
        console.log('Photos after upload:', photosAfterUpload);
        expect(photosAfterUpload).toContain('New Photo');
    }, 240000); // Increase the timeout for this test to 240 seconds
});


################################################################################
File: ./wireless/wifi_manager.py
import subprocess
import socket
from zeroconf import ServiceBrowser, Zeroconf
from typing import Dict


def get_self_ip_address():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        # Unreachable ID address to force socket open
        s.connect(('10.254.254.254',1))
        ip_address = s.getsockname()[0]
    except Exception:
        ip_address = '127.0.0.1'
    finally:
        s.close()

    return ip_address

# This class handles wifi scanning and hostname lookups to check for DFP devices connected to the network
class WifiManager:
     
    # Ping network to ensure mDNS devices appear in ARP table to grab MAC Address
    @staticmethod
    def ping_device(ip):
        subprocess.run(['ping', '-c','1','-W','1',ip], stdout=subprocess.DEVNULL)
    
    # Get arp table to find ip and mac addresses
    @staticmethod
    def get_arp_table():
        result = subprocess.run(['arp', '-a'], capture_output=True, text=True)
        return result.stdout

    # Find mDNS services on network and get hostnames from devices, avahi-daemon must be running on rpi to register
    # hostname with mDNS service
    @staticmethod
    def get_hostname_from_mdns(timeout=5) -> Dict[str, str]:

        # Handles service discovery events
        class MyListener:
            def __init__(self):
                self.devices = {}

            # Place holder
            def remove_service(self, zeroconf, type, name):
                pass
            
            # Place holder
            def update_service(self, zeroconf, type, name):
                pass

            # Get detailed information about the service, extract hostname, check if DPF device and add to device
            # dictionary
            def add_service(self, zeroconf, type, name):
                info = zeroconf.get_service_info(type, name)
                #print(f"add_service info:\n{info}")
                if info:
                    # Convert ip address to string
                    if info.addresses:
                        address = socket.inet_ntoa(info.addresses[0])
                        # Extracting the hostname without domain
                        hostname = info.server.split('.')[0]
                        if 'FrameCast' in hostname:
                            self.devices[address] = hostname
                    else:
                        info = zeroconf.get_service_info(type, name)
                        if info:
                            # Convert ip address to string
                            if info.addresses:
                                address = socket.inet_ntoa(info.addresses[0])
                                # Extracting the hostname without domain
                                hostname = info.server.split('.')[0]
                                if 'FrameCast' in hostname:
                                    self.devices[address] = hostname

            def get_devices(self):
                return self.devices

        # Initialize zeroconf and a mylistener to handle discovery events, and start looking for services on the network
        zeroconf = Zeroconf()
        listener = MyListener()
        browser = ServiceBrowser(zeroconf, "_workstation._tcp.local.", listener)

        # Wait for services to be found, then stop zerconf
        import time
        time.sleep(timeout)

        zeroconf.close()

        # Return device dictionary<key=ip address, value=hostname>
        return listener.get_devices()

    # Look at devices currently connected to network, find the DFP devices, extract info from hostnames and return a
    # map of found DFP objects
    @staticmethod
    def enumerate_wifi_devices():
        
        # Get arp table and hostnames
        
        mdns_hosts = WifiManager.get_hostname_from_mdns()
        print(f"mDNS hosts:\n{mdns_hosts}")
        for ip, hostname in mdns_hosts.items():
            WifiManager.ping_device(ip)
    
        arp_output = WifiManager.get_arp_table()
        print(f"ARP Output:\n{arp_output}")

        # Store connected DFP objects
        # Principal adds self to dictionary since it won't appear in ARP table
        
        self_hostname = socket.gethostname()
        print(f"Self hostname: {self_hostname}")
        self_ip_address = get_self_ip_address()
        
        network_devices = [{
            "MAC Address":"NA",
            "Host Name": self_hostname,
            "IP Address":self_ip_address
            }]
        
        # Parse the ARP table
        for line in arp_output.splitlines():
            #if line.strip() and 'dynamic' in line:
            if line.strip():
                
                parts = line.split()
                print(parts)
                ip_address = parts[1].strip("()")
                mac_address = parts[3]

                # Check if the IP address is in the mDNS hostnames
                if ip_address in mdns_hosts:

                    # Extract hostname and serial number
                    hostname = mdns_hosts[ip_address]
                    device_sn = hostname.split('-')[-1]

                    # Make new dict object
                    deviceConfig = {
                        "MAC Address":mac_address,
                        "Host Name": hostname,
                        "IP Address":ip_address
                    }
                
                    network_devices.append(deviceConfig)

        return network_devices


################################################################################
File: ./wireless/wifi_connection.py
import os
import subprocess
import sys

def main(args):
	
	print("Running wireless script")
	
	if len(args) != 2:
		print("Error: Expected two arguments")
		exit(1)
	if os.geteuid() != 0:
		print("Error: This script must be run as root")
		exit(1)

	ssid = args[0]
	psk = args[1]
	
	print(f"Received arguments: {ssid} and {psk}")
	
	# Run command to connect to wifi network
	try:
			print("Connecting...")
			subprocess.run(['nmcli', 'dev', 'wifi', 'connect', ssid, 'password', psk], check=True)
			#client_socket.send("OK")

	except subprocess.CalledProcessError as e:
			print('Failed to connect')
			#client_socket.send("Failed to connect")
			exit(1)

	#client_socket.close()
	#server_socket.close()

	# Restart avahi-daemon just in case to make sure rpi hostname is advertised so enumerate_wifi_devices can read it
	subprocess.run(['sudo', 'systemctl', 'restart', 'avahi-daemon'], check=True)

if __name__ == '__main__':
	main(sys.argv[1:])






################################################################################
File: ./wireless/bluetooth_connection.py
import bluetooth
import os
import subprocess
from base64 import b64decode, b64encode
from Cryptodome.Cipher import AES
from Cryptodome.Util.Padding import unpad

def decrypt(encrypted_text, key):
	
	encrypted_bytes = b64decode(encrypted_text)
	key_bytes = b64decode(key)
	
	cipher = AES.new(key_bytes, AES.MODE_ECB)
	
	decrypted_bytes = unpad(cipher.decrypt(encrypted_bytes), AES.block_size)
	
	return decrypted_bytes.decode('utf-8')

if os.geteuid() != 0:
	print("This script must be run as root")
	exit(1)

# Set socket to listen for bluetooth connection from app or web portal
server_socket = bluetooth.BluetoothSocket(bluetooth.RFCOMM)

port = 1
server_socket.bind(("", port))

server_socket.listen(1)
port = server_socket.getsockname()[1]

server_socket.settimeout(180)

# Advertise service with UUID for bluetooth connection from app
bluetooth.advertise_service(server_socket, "Pi4Server",
							service_id = "00001101-0000-1000-8000-00805F9B34FB",
							service_classes = ["00001101-0000-1000-8000-00805F9B34FB", bluetooth.SERIAL_PORT_CLASS],
							profiles = [bluetooth.SERIAL_PORT_PROFILE])
							
print("Bluetooth service advertised. Waiting for connection...")							

try:
	# Get socket and address from device trying to connect
	client_socket, address = server_socket.accept()
except bluetooth.BluetoothError as e:
	print("No connection was made within the timeout period")
	server_socket.close()
	exit(1)


ssid = None
psk = None
encrypted_password = None
secret_key = None

try:

	while True:
		data = client_socket.recv(1024).decode('utf-8')
		if len(data) == 0:
			exit
		print(f"Recieved: {data}")
		recieved_data = data.split("/n")
		print(f"Recieved: {recieved_data}")
		
		ssid = recieved_data[0]
		print("SSID: ", ssid)
		encrypted_password = recieved_data[1]
		secret_key = recieved_data[2]
		
		print(encrypted_password)
		print(secret_key)
		if (ssid and encrypted_password and secret_key):
			break

except OSError:
	pass
	
psk = decrypt(encrypted_password, secret_key)
print("Decrypted password: ", psk)

print(f"WIFI: {ssid} {psk}")

client_socket.close()
server_socket.close()





################################################################################
File: ./wireless/bluetoothsocketUpd.py
import bluetooth
import os
import subprocess
from base64 import b64decode, b64encode
from Cryptodome.Cipher import AES
from Cryptodome.Util.Padding import unpad

def decrypt(encrypted_text, key):
	
	encrypted_bytes = b64decode(encrypted_text)
	key_bytes = b64decode(key)
	
	cipher = AES.new(key_bytes, AES.MODE_ECB)
	
	decrypted_bytes = unpad(cipher.decrypt(encrypted_bytes), AES.block_size)
	
	return decrypted_bytes.decode('utf-8')



subprocess.run(['sudo', 'hciconfig', 'hci0', 'up'], check=True)
subprocess.run(['sudo', 'hciconfig', 'hci0', 'piscan'], check=True)
subprocess.run(['sudo', 'btmgmt', 'io-cap', '3'], check=True)

server_socket = bluetooth.BluetoothSocket(bluetooth.RFCOMM)

port = 1
server_socket.bind(("", port))
print ("Socket Bound")
server_socket.listen(1)
port = server_socket.getsockname()[1]
print (f"Socket Listening on RFCOMM channel {port}")
print ("Socket: %s" %server_socket)

bluetooth.advertise_service(server_socket, "Pi4Server",
							service_id = "00001101-0000-1000-8000-00805F9B34FB",
							service_classes = ["00001101-0000-1000-8000-00805F9B34FB", bluetooth.SERIAL_PORT_CLASS],
							profiles = [bluetooth.SERIAL_PORT_PROFILE])
							
print ("Service advertised")
client_socket, address = server_socket.accept()
print ("Accepted connection from", address)

ssid = None
psk = None
encrypted_password = None
secret_key = None

try:
	while True:
		data = client_socket.recv(1024).decode('utf-8')
		if len(data) == 0:
			exit
		print(f"Recieved: {data}")
		recieved_data = data.split("/n")
		print(f"Recieved: {recieved_data}")
		
		ssid = recieved_data[0]
		print("SSID: ", ssid)
		encrypted_password = recieved_data[1]
		secret_key = recieved_data[2]
		
		print(encrypted_password)
		print(secret_key)
		if (ssid and encrypted_password and secret_key):
			break
	
except OSError:
	pass

if os.geteuid() != 0:
		print("This script must be run as root")
		exit(1)

psk = decrypt(encrypted_password, secret_key)
print("Decrypted password: ", psk)

try:
		print("connecting...")
		subprocess.run(['nmcli', 'dev', 'wifi', 'connect', ssid, 'password', psk], check=True)
		connected = True

except subprocess.CalledProcessError as e:
		print('Failed to connect')
		connect = False
		exit(1)

if (connected):
	try:
		print("Sending confirmation")
		while True:
			print("Sending ok")
			client_socket.send("OK")
			print("OK Sent")
	except OSError as e:
		print("OSError: ", e)
	except bluetooth.btcomm.BluetoothError as e:
		print("Bluetooth error: ", e)
else:
	try:
		print("Sending Failure")
		while True:
			client_socket.send("FAIL")
			print("Fail sent")
	except OSError:
		pass
	
print("closing sockets")
client_socket.close()
server_socket.close()

subprocess.run(['sudo', 'systemctl', 'restart', 'avahi-daemon'], check=True)

def decrypt(encrypted_text, key):
	
	encrypted_bytes = b64decode(encrypted_text)
	key_bytes = b64decode(key)
	
	cipher = AES.new(key_bytes, AES.MODE_ECB)
	
	decrypted_bytes = unpad(cipher.decrypt(encrypted_bytes), AES.block_size)
	
	return decrypted_bytes.decode('utf-8')





################################################################################
File: ./wireless/bluetooth_manager.py
import bluetooth
from Cryptodome.Cipher import AES
from Cryptodome.Util.Padding import pad
from Cryptodome.Random import get_random_bytes
from base64 import b64encode, b64decode
import subprocess

def encrypt(text, key):
    key_bytes = b64decode(key)
    cipher = AES.new(key_bytes, AES.MODE_ECB)
    encrypted_bytes = cipher.encrypt(pad(text.encode('utf-8'),AES.block_size))
    return b64encode(encrypted_bytes).decode('utf-8')

# Get SSID for currently connected network
def get_ssid():
    try:
        # Run nmcli command to get the active Wi-Fi SSID
        result = subprocess.run(
            ['nmcli', '-t', '-f', 'active,ssid', 'dev', 'wifi'],
            capture_output=True,
            text=True,
            check=True
        )
        # Filter the active connections
        for line in result.stdout.splitlines():
            if line.startswith('yes:'):
                return line.split(':')[1]
        return None
    except subprocess.CalledProcessError as e:
        print(f"Error getting SSID: {e}")
        return None


# Get PSK for currently connected network
def get_password(ssid):
    try:
        # Run nmcli command to get the connection details for the SSID
        result = subprocess.run(
            ['nmcli', '-s', 'connection', 'show', ssid],
            capture_output=True,
            text=True,
            check=True
        )
        # Extract the PSK (password) from the connection details
        for line in result.stdout.splitlines():
            if '802-11-wireless-security.psk:' in line:
                return line.split(':')[1].strip()
        return None
    except subprocess.CalledProcessError as e:
        print(f"Error getting password: {e}")
        return None


# This class handles bluetooth scanning and communication
class BluetoothManager:

    # List nearby DPF devices
    @staticmethod
    def find_discoverable_bluetooth_devices():

        # Scan and store nearby discoverable bluetooth devices
        #nearby_devices = bluetooth.discover_devices(lookup_names=True, device_id=True, flush_cache=True)
        nearby_devices = bluetooth.discover_devices(duration=8,lookup_names=True,flush_cache=True)

        # Found DPF device objects will be stored here
        discovered_devices = []

        # Loop through found bluetooth devices and check for DPF devices, if found make a new DPF object and add it
        # to list
        for addr, name in nearby_devices:

            print(f"{addr} - {name}")
            # Check if DPF device
            if name.startswith("FrameCast"):

                parts = name.split("-")

                # If DPF device found extract info from device name and make new DPF object
                if len(parts) == 4 and (parts[2] == "Principal" or parts[2] == "Agent"):

                    device_sn = parts[3]
                    device_type = parts[2]

                deviceConfig = {
                    "Serial Number":device_sn,
                    "Host Name": name,
                    "Type":device_type,
                    "MAC Address":addr
                };
                
                discovered_devices.append(deviceConfig)

        return discovered_devices

    # Loop through discovered DPF devices and send wifi credentials to each, recieving and actual connection to
    # network will be handled on the DPF device side
    @staticmethod
    def invite_discovered_device_to_network(invited_devices):

        # List to hold values for if a device was connected
        connected_list = []

        # Get wifi credentials from currently connected network
        ssid = get_ssid()
        psk = get_password(ssid)
        secret_key = b64encode(get_random_bytes(16)).decode('utf-8')
        encrypted_password = encrypt(psk,secret_key)
        print(f"SSID: {ssid}\npsk: {psk}\nSecret Key: {secret_key}")

        # Loop through discovered devices, connect over bluetooth and send credentials
        for device in invited_devices:
            
            mac_addr = device["MAC Address"]

            try:
                port = 1  # Commonly used port for Bluetooth communication

                # Setup socket for communication and connect to DFP device.  DFP device must have socket setup to
                # listen, will be handled by script running on DFP device
                sock = bluetooth.BluetoothSocket(bluetooth.RFCOMM)
                sock.connect((mac_addr, port))

                # Send credentials and wait a bit for DFP devices to connect to network
                sock.send(f"{ssid}/n{encrypted_password}/n{secret_key}")
                sock.settimeout(15)

                # Listen for confirmation of successful connection from DFP devices, if received update connected
                # list with true.  If no confirmation or an error update list with false
                try:
                    confirmation = sock.recv(1024).decode('utf-8').strip()
                    if confirmation == "OK":
                        sock.close()
                        connected_list.append(True)
                    else:
                        sock.close()
                        connected_list.append(False)

                except bluetooth.btcommon.BluetoothError as e:
                    print(f"Failed to receive confirmation from {mac_addr}: {e}")
                    sock.close()
                    connected_list.append(False)
            except bluetooth.BluetoothError as e:
                print(f"Failed to send SSID and password to {mac_addr}: {e}")
                connected_list.append(False)

        return connected_list



################################################################################
File: ./wireless/api.py
from bluetooth_manager import BluetoothManager
from wifi_manager import WifiManager

class DigitalPhotoFrameAPI:
    @staticmethod
    def find_discoverable_bluetooth_devices():
        return BluetoothManager.find_discoverable_bluetooth_devices()

    @staticmethod
    def invite_discovered_devices_to_network(discovered_devices):
        return BluetoothManager.invite_discovered_device_to_network(discovered_devices)

    @staticmethod
    def enumerate_wifi_devices():
        return WifiManager.enumerate_wifi_devices()


################################################################################
File: ./wireless/bluetooth_connection_TESTED.py
import bluetooth
import os
import subprocess

if os.geteuid() != 0:
	print("This script must be run as root")
	exit(1)

# Set socket to listen for bluetooth connection from app or web portal
server_socket = bluetooth.BluetoothSocket(bluetooth.RFCOMM)

port = 1
server_socket.bind(("", port))

server_socket.listen(1)
port = server_socket.getsockname()[1]

server_socket.settimeout(180)

# Advertise service with UUID for bluetooth connection from app
bluetooth.advertise_service(server_socket, "Pi4Server",
							service_id = "00001101-0000-1000-8000-00805F9B34FB",
							service_classes = ["00001101-0000-1000-8000-00805F9B34FB", bluetooth.SERIAL_PORT_CLASS],
							profiles = [bluetooth.SERIAL_PORT_PROFILE])
							
print("Bluetooth service advertised. Waiting for connection...")							

try:
	# Get socket and address from device trying to connect
	client_socket, address = server_socket.accept()
except bluetooth.BluetoothError as e:
	print("No connection was made within the timeout period")
	server_socket.close()
	exit(1)

ssid = None
psk = None

try:

	# Read wifi credential info sent from connected device
	data = client_socket.recv(1024).decode('utf-8')
	if len(data) == 0:
		exit
	recieved_data = data.split("/n")

	ssid = recieved_data[0]
	psk = recieved_data[1]

except OSError:
	pass

print(f"WIFI: {ssid} {psk}")

client_socket.close()
server_socket.close()





################################################################################
File: ./wireless/bluetooth_manager_TESTED.py
import bluetooth
import subprocess


# Get SSID for currently connected network
def get_ssid():
    try:
        # Run nmcli command to get the active Wi-Fi SSID
        result = subprocess.run(
            ['nmcli', '-t', '-f', 'active,ssid', 'dev', 'wifi'],
            capture_output=True,
            text=True,
            check=True
        )
        # Filter the active connections
        for line in result.stdout.splitlines():
            if line.startswith('yes:'):
                return line.split(':')[1]
        return None
    except subprocess.CalledProcessError as e:
        print(f"Error getting SSID: {e}")
        return None


# Get PSK for currently connected network
def get_password(ssid):
    try:
        # Run nmcli command to get the connection details for the SSID
        result = subprocess.run(
            ['nmcli', '-s', 'connection', 'show', ssid],
            capture_output=True,
            text=True,
            check=True
        )
        # Extract the PSK (password) from the connection details
        for line in result.stdout.splitlines():
            if '802-11-wireless-security.psk:' in line:
                return line.split(':')[1].strip()
        return None
    except subprocess.CalledProcessError as e:
        print(f"Error getting password: {e}")
        return None


# This class handles bluetooth scanning and communication
class BluetoothManager:

    # List nearby DPF devices
    @staticmethod
    def find_discoverable_bluetooth_devices():

        # Scan and store nearby discoverable bluetooth devices
        #nearby_devices = bluetooth.discover_devices(lookup_names=True, device_id=True, flush_cache=True)
        nearby_devices = bluetooth.discover_devices(duration=8,lookup_names=True,flush_cache=True)

        # Found DPF device objects will be stored here
        discovered_devices = []

        # Loop through found bluetooth devices and check for DPF devices, if found make a new DPF object and add it
        # to list
        for addr, name in nearby_devices:

            print(f"{addr} - {name}")
            # Check if DPF device
            if name.startswith("FrameCast"):

                parts = name.split("-")

                # If DPF device found extract info from device name and make new DPF object
                if len(parts) == 4 and (parts[2] == "Principal" or parts[2] == "Agent"):

                    device_sn = parts[3]
                    device_type = parts[2]

                deviceConfig = {
                    "Serial Number":device_sn,
                    "Host Name": name,
                    "Type":device_type,
                    "MAC Address":addr
                };
                
                discovered_devices.append(deviceConfig)

        return discovered_devices

    # Loop through discovered DPF devices and send wifi credentials to each, recieving and actual connection to
    # network will be handled on the DPF device side
    @staticmethod
    def invite_discovered_device_to_network(invited_devices):

        # List to hold values for if a device was connected
        connected_list = []

        # Get wifi credentials from currently connected network
        ssid = get_ssid()
        psk = get_password(ssid)

        # Loop through discovered devices, connect over bluetooth and send credentials
        for device in invited_devices:
            
            mac_addr = device["MAC Address"]

            try:
                port = 1  # Commonly used port for Bluetooth communication

                # Setup socket for communication and connect to DFP device.  DFP device must have socket setup to
                # listen, will be handled by script running on DFP device
                sock = bluetooth.BluetoothSocket(bluetooth.RFCOMM)
                sock.connect((mac_addr, port))

                # Send credentials and wait a bit for DFP devices to connect to network
                sock.send(f"{ssid}/n{psk}/n")
                sock.settimeout(15)

                # Listen for confirmation of successful connection from DFP devices, if received update connected
                # list with true.  If no confirmation or an error update list with false
                try:
                    confirmation = sock.recv(1024).decode('utf-8').strip()
                    if confirmation == "OK":
                        sock.close()
                        connected_list.append(True)
                    else:
                        sock.close()
                        connected_list.append(False)

                except bluetooth.btcommon.BluetoothError as e:
                    print(f"Failed to receive confirmation from {mac_addr}: {e}")
                    sock.close()
                    connected_list.append(False)
            except bluetooth.BluetoothError as e:
                print(f"Failed to send SSID and password to {mac_addr}: {e}")
                connected_list.append(False)

        return connected_list



################################################################################
File: ./wireless/bluetoothsocket.py
import bluetooth
import os
import subprocess

if os.geteuid() != 0:
		print("This script must be run as root")
		exit(1)

# Set socket to listen for bluetooth connection from app or web portal
server_socket = bluetooth.BluetoothSocket(bluetooth.RFCOMM)

port = 1
server_socket.bind(("", port))

server_socket.listen(1)
port = server_socket.getsockname()[1]

server_socket.settimeout(10)

# Advertise service with UUID for bluetooth connection from app
bluetooth.advertise_service(server_socket, "Pi4Server",
							service_id = "00001101-0000-1000-8000-00805F9B34FB",
							service_classes = ["00001101-0000-1000-8000-00805F9B34FB", bluetooth.SERIAL_PORT_CLASS],
							profiles = [bluetooth.SERIAL_PORT_PROFILE])
							
print("Bluetooth service advertised. Waiting for connection...")							

try:
	# Get socket and address from device trying to connect
	client_socket, address = server_socket.accept()
except bluetooth.BluetoothError as e:
	print("No connection was made within the timeout period")
	server_socket.close()
	exit(1)

ssid = None
psk = None

try:

	# Read wifi credential info sent from connected device
	data = client_socket.recv(1024).decode('utf-8')
	if len(data) == 0:
		exit
	recieved_data = data.split("/n")

	ssid = recieved_data[0]
	psk = recieved_data[1]

except OSError:
	pass

# Run command to connect to wifi network
try:
		print("Scanning for available networks...")
		result = subprocess.run(['nmcli', 'dev', 'wifi', 'rescan'], capture_output = True, text = True)
		print("Connecting to target network...")
		subprocess.run(['nmcli', 'dev', 'wifi', 'connect', ssid, 'password', psk], check=True)
		client_socket.send("OK")

except subprocess.CalledProcessError as e:
		print('Failed to connect')
		client_socket.send("Failed to connect")
		exit(1)

client_socket.close()
server_socket.close()

# Restart avahi-daemon just in case to make sure rpi hostname is advertised so enumerate_wifi_devices can read it
subprocess.run(['sudo', 'systemctl', 'restart', 'avahi-daemon'], check=True)







################################################################################
File: ./static/photo-editor-app.js
/**
 * Fetch all photos from the server and update the photo list in the UI
 */
function getAllPhotos() {
    console.log("Fetching all photos...");
    fetch('/api/get_all_photos')
        .then(response => response.json())
        .then(data => {
            console.log("Photos fetched:", data);
            let photoList = document.querySelector('.photo-list');
            photoList.innerHTML = '';
            for (let id in data) {
                let photo = data[id];
                const label = document.createElement('label');
                label.innerHTML = `<input type="radio" name="photo" value="${id}"> ${photo.photo_name}`;
                label.querySelector('input').addEventListener('change', () => {
                    getPhotoConfig(id);
                });
                photoList.appendChild(label);
            }
        })
        .catch(error => console.error('Error fetching photos:', error));
}

/**
 * Fetch the configuration for a specific photo and update the UI with the photo details
 * @param {string} photo_id - The ID of the photo to fetch
 */
function getPhotoConfig(photo_id) {
    console.log(`Fetching photo config for ${photo_id}...`);
    fetch(`/api/get_photo/${photo_id}`)
        .then(response => response.json())
        .then(data => {
            console.log("Photo config fetched:", data);
            const previewImage = document.querySelector('.preview-image');
            if (!data.path) {
                console.error("Image path is empty.");
                previewImage.src = "";
            } else {
                previewImage.src = data.path;
                console.log("Image path set to:", data.path);
            }
            previewImage.dataset.rotation = data.rotation;
            previewImage.dataset.scaling = data.scaling;
            previewImage.dataset.x = data.split_screen.x;
            previewImage.dataset.y = data.split_screen.y;
            previewImage.dataset.width = data.split_screen.width;
            previewImage.dataset.height = data.split_screen.height;

            document.querySelector('.scale-input').value = data.scaling;
            document.querySelector('.split-screen-x').value = data.split_screen.x;
            document.querySelector('.split-screen-y').value = data.split_screen.y;
            document.querySelector('.split-screen-width').value = data.split_screen.width;
            document.querySelector('.split-screen-height').value = data.split_screen.height;

            document.querySelector('.rotate-ccw').dataset.photoId = data.photo_id;
            document.querySelector('.rotate-cw').dataset.photoId = data.photo_id;
            document.querySelector('.scale').dataset.photoId = data.photo_id;
            document.querySelector('.save').dataset.photoId = data.photo_id;

            updatePreviewImage(data.rotation, data.scaling, data.split_screen.x, data.split_screen.y, data.split_screen.width, data.split_screen.height);
        })
        .catch(error => console.error('Error fetching photo config:', error));
}

/**
 * Update the preview image with the specified rotation, scaling, and position
 * @param {number} rotation - The rotation angle of the photo
 * @param {number} scaling - The scaling percentage of the photo
 * @param {number} x - The x position of the photo
 * @param {number} y - The y position of the photo
 * @param {number} width - The width percentage of the photo
 * @param {number} height - The height percentage of the photo
 */
function updatePreviewImage(rotation, scaling, x, y, width, height) {
    console.log(`Updating preview image with rotation: ${rotation}, scaling: ${scaling}, x: ${x}, y: ${y}, width: ${width}, height: ${height}`);
    const previewImage = document.querySelector('.preview-image');
    previewImage.style.transform = `translate(-50%, -50%) rotate(${rotation}deg) scale(${scaling / 100})`;
    previewImage.style.position = 'absolute';
    previewImage.style.left = `${x}%`;
    previewImage.style.top = `${y}%`;
    previewImage.style.width = `${width}%`;
    previewImage.style.height = `${height}%`;
    console.log(`Preview image styles: transform=${previewImage.style.transform}, position=${previewImage.style.position}, left=${previewImage.style.left}, top=${previewImage.style.top}, width=${previewImage.style.width}, height=${previewImage.style.height}`);
    console.log(`Preview image src: ${previewImage.src}`);
}




/**
 * Rotate the photo counterclockwise by 90 degrees
 */
function rotatePhotoCCW() {
    console.log("Rotating photo counterclockwise...");
    const photoId = this.dataset.photoId;
    const previewImage = document.querySelector('.preview-image');
    const currentRotation = parseInt(previewImage.dataset.rotation);
    const newRotation = (currentRotation - 90 + 360) % 360; // Ensure rotation is always positive
    console.log(`Current rotation: ${currentRotation}, new rotation: ${newRotation}`);
    previewImage.dataset.rotation = newRotation;
    updatePreviewImage(newRotation, parseInt(previewImage.dataset.scaling), parseInt(previewImage.dataset.x), parseInt(previewImage.dataset.y), parseInt(previewImage.dataset.width), parseInt(previewImage.dataset.height));
    savePhotoConfig(photoId, newRotation, parseInt(previewImage.dataset.scaling), parseInt(previewImage.dataset.x), parseInt(previewImage.dataset.y), parseInt(previewImage.dataset.width), parseInt(previewImage.dataset.height));
}

/**
 * Rotate the photo clockwise by 90 degrees
 */
function rotatePhotoCW() {
    console.log("Rotating photo clockwise...");
    const photoId = this.dataset.photoId;
    const previewImage = document.querySelector('.preview-image');
    const currentRotation = parseInt(previewImage.dataset.rotation);
    const newRotation = (currentRotation + 90) % 360;
    console.log(`Current rotation: ${currentRotation}, new rotation: ${newRotation}`);
    previewImage.dataset.rotation = newRotation;
    updatePreviewImage(newRotation, parseInt(previewImage.dataset.scaling), parseInt(previewImage.dataset.x), parseInt(previewImage.dataset.y), parseInt(previewImage.dataset.width), parseInt(previewImage.dataset.height));
    savePhotoConfig(photoId, newRotation, parseInt(previewImage.dataset.scaling), parseInt(previewImage.dataset.x), parseInt(previewImage.dataset.y), parseInt(previewImage.dataset.width), parseInt(previewImage.dataset.height));
}

/**
 * Scale the photo to the specified percentage
 */
function scalePhoto() {
    console.log("Scaling photo...");
    const photoId = this.dataset.photoId;
    const newScaling = document.querySelector('.scale-input').value;
    const previewImage = document.querySelector('.preview-image');
    console.log(`New scaling: ${newScaling}`);
    previewImage.dataset.scaling = newScaling;
    updatePreviewImage(parseInt(previewImage.dataset.rotation), newScaling, parseInt(previewImage.dataset.x), parseInt(previewImage.dataset.y), parseInt(previewImage.dataset.width), parseInt(previewImage.dataset.height));
    savePhotoConfig(photoId, parseInt(previewImage.dataset.rotation), newScaling, parseInt(previewImage.dataset.x), parseInt(previewImage.dataset.y), parseInt(previewImage.dataset.width), parseInt(previewImage.dataset.height));
}

/**
 * Save the photo configuration to the server
 * @param {string} photo_id - The ID of the photo to save
 * @param {number} rotation - The rotation angle of the photo
 * @param {number} scaling - The scaling percentage of the photo
 * @param {number} x - The x position of the photo
 * @param {number} y - The y position of the photo
 * @param {number} width - The width percentage of the photo
 * @param {number} height - The height percentage of the photo
 */
function savePhotoConfig(photo_id, rotation, scaling, x, y, width, height) {
    let window = { x: 0, y: 0 };
    let splitScreen = { x: x, y: y, width: width, height: height };

    let photoConfig = {
        photo_id: photo_id,
        rotation: rotation,
        scaling: scaling,
        window: window,
        split_screen: splitScreen
    };

    console.log("Saving photo config:", photoConfig);

    fetch('/api/save_photo_config', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(photoConfig)
    })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                console.log('Photo configuration saved successfully');
            }
        })
        .catch(error => console.error('Error saving photo configuration:', error));
}

/**
 * Upload photo function to handle the form submission
 */
function uploadPhoto(event) {
    event.preventDefault();
    const formData = new FormData(document.getElementById('upload-form'));
    fetch('/api/upload_photo', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            console.log('Photo uploaded successfully');
            getAllPhotos(); // Refresh the photo list
        } else {
            console.error('Error uploading photo:', data.error);
        }
    })
    .catch(error => console.error('Error uploading photo:', error));
}

// Event listener for when the document content is loaded
document.addEventListener('DOMContentLoaded', () => {
    console.log("Document loaded, fetching initial data...");
    getAllPhotos();

    // Add event listeners for rotate and scale buttons
    document.querySelector('.rotate-ccw').addEventListener('click', rotatePhotoCCW);
    document.querySelector('.rotate-cw').addEventListener('click', rotatePhotoCW);
    document.querySelector('.scale').addEventListener('click', scalePhoto);
    document.querySelector('.save').addEventListener('click', (event) => {
        const photoId = event.target.dataset.photoId;
        const rotation = parseInt(document.querySelector('.preview-image').dataset.rotation);
        const scaling = parseInt(document.querySelector('.preview-image').dataset.scaling);
        const x = parseInt(document.querySelector('.split-screen-x').value);
        const y = parseInt(document.querySelector('.split-screen-y').value);
        const width = parseInt(document.querySelector('.split-screen-width').value);
        const height = parseInt(document.querySelector('.split-screen-height').value);
        savePhotoConfig(photoId, rotation, scaling, x, y, width, height);
    });

    // Add event listeners for split-screen controls
    document.querySelectorAll('.split-screen-x, .split-screen-y, .split-screen-width, .split-screen-height').forEach(input => {
        input.addEventListener('input', () => {
            const rotation = parseInt(document.querySelector('.preview-image').dataset.rotation);
            const scaling = parseInt(document.querySelector('.preview-image').dataset.scaling);
            const x = parseInt(document.querySelector('.split-screen-x').value);
            const y = parseInt(document.querySelector('.split-screen-y').value);
            const width = parseInt(document.querySelector('.split-screen-width').value);
            const height = parseInt(document.querySelector('.split-screen-height').value);
            updatePreviewImage(rotation, scaling, x, y, width, height);
        });
    });
});

document.getElementById('upload-form').addEventListener('submit', uploadPhoto);


################################################################################
File: ./static/style_device_editor.css
/* ./static/style_device_editor.css */

/* General styles for the body */
body {
  font-family: 'Inter', sans-serif;
  margin: 0;
  padding: 0;
  background-color: #fff;
  text-align: center;
  display: flex;
  flex-direction: column;
}

/* Navbar styles */
.navbar {
  display: flex;
  justify-content: space-around;
  padding: 20px;
  background-color: #d9d9d9;
  border-bottom: 4px solid #000;
  width: 100%;
  box-sizing: border-box;
  text-decoration: none;
}

/* Navbar item styles */
.navbar-item {
  margin: 0;
  padding: 5px;
  font-size: 24px;
  font-weight: 800;
  cursor: pointer;
  text-decoration: none;
  color: inherit;
  transition: transform 0.3s ease, color 0.3s ease;
}

/* Navbar item hover effect */
.navbar-item:hover {
  transform: scale(1.1);
  color: #ff6f61;
}

/* Highlighted navbar item */
.navbar-item.highlight {
  background-color: #ffeb3b;
  padding: 5px;
  border-radius: 5px;
}

/* Main content styles */
.main-content {
  display: flex;
  flex-direction: row;
  align-items: center;
  padding: 20px;
  gap: 10px;
  width: 100%;
  box-sizing: border-box;
}

/* Section title styles */
.section-title {
  font-size: 20px;
  font-weight: 800;
}

/* Styles for sections containing lists and configurations */
.photo-list-section,
.device-list-section,
.device-config-pane {
  display: flex;
  flex-direction: column;
  align-items: center;
  border: 4px solid #000;
  padding: 10px;
  background-color: #d9d9d9; /* Gray background */
  box-sizing: border-box;
  flex: 1;
}

/* List styles for photos, devices, and assigned photos */
.photo-list,
.device-list,
.assigned-photo-list {
  display: flex;
  flex-direction: column;
  gap: 5px;
  padding: 10px;
}

/* Configuration item and button group styles */
.config-item,
.button-group {
  margin-bottom: 10px;
}

/* Action button styles */
.action-button {
  padding: 10px 20px;
  margin: 10px;
  border: none;
  background-color: #a9a9a9;
  font-size: 16px;
  cursor: pointer;
  transition: background-color 0.3s ease, transform 0.3s ease;
}

/* Action button hover effect */
.action-button:hover {
  background-color: #8c8c8c;
  transform: scale(1.05);
}

/* Preview image styles */
.preview-image {
  max-width: 100%;
  height: auto;
}

/* Preview section styles */
.preview {
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* Responsive styles for screens with a maximum width of 1200px */
@media screen and (max-width: 1200px) {
  .main-content {
    flex-direction: column;
    align-items: center;
  }

  .photo-list-section,
  .device-list-section,
  .device-config-pane {
    width: 100%;
  }

  .preview-image {
    max-width: 80%;
  }
}

/* Responsive styles for screens with a maximum width of 768px */
@media screen and (max-width: 768px) {
  .main-content {
    flex-direction: column;
    align-items: center;
    padding: 10px;
  }

  .photo-list-section,
  .device-list-section,
  .device-config-pane {
    width: 100%;
    padding: 5px;
  }

  .section-title {
    font-size: 20px;
  }

  .preview-image {
    max-width: 70%;
  }

  .action-button {
    font-size: 14px;
  }
}

/* Responsive styles for screens with a maximum width of 480px */
@media screen and (max-width: 480px) {
  .main-content {
    padding: 5px;
  }

  .photo-list-section,
  .device-list-section,
  .device-config-pane {
    padding: 10px;
  }

  .section-title {
    font-size: 20px;
  }

  .preview-image {
    max-width: 60%;
  }

  .action-button {
    padding: 3px;
    font-size: 14px;
  }
}

/* Responsive navbar styles for screens with a maximum width of 768px */
@media screen and (max-width: 768px) {
  .navbar {
    flex-direction: row;
    align-items: center;
  }
}

/* Responsive navbar item styles for screens with a maximum width of 768px */
@media screen and (max-width: 768px) {
  .navbar-item {
    font-size: 18px;
    margin: 10px 0;
  }
}


################################################################################
File: ./static/device-editor-app.js
document.addEventListener('DOMContentLoaded', () => {
    console.log("Document loaded, fetching initial data...");
    getAllPhotos();
    getAllDevices();
    populateDeviceDropdown();
});

function getAllPhotos() {
    console.log("Fetching all photos...");
    fetch('/api/get_all_photos')
        .then(response => response.json())
        .then(data => {
            console.log("Photos fetched:", data);
            let photoList = document.getElementById('photo-list');
            photoList.innerHTML = '';
            for (let id in data) {
                let photo = data[id];
                const label = document.createElement('label');
                label.innerHTML = `<input type="checkbox" name="photo" value="${id}"> ${photo.photo_name}`;
                label.querySelector('input').addEventListener('change', () => {
                    updatePhotoPreviews();
                });
                photoList.appendChild(label);
            }
        })
        .catch(error => console.error('Error fetching photos:', error));
}

function updatePhotoPreviews() {
    let selectedPhotoIds = Array.from(document.querySelectorAll('input[name="photo"]:checked')).map(input => input.value);
    let photoPreviews = document.getElementById('photo-previews');
    photoPreviews.innerHTML = '';

    selectedPhotoIds.forEach(photoId => {
        fetch(`/api/get_photo/${photoId}`)
            .then(response => response.json())
            .then(data => {
                const img = document.createElement('img');
                img.src = data.path;
                img.classList.add('preview-image');
                photoPreviews.appendChild(img);
            })
            .catch(error => console.error('Error fetching photo:', error));
    });
}

function getAllDevices() {
    console.log("Fetching all devices...");
    fetch('/api/get_all_devices')
        .then(response => response.json())
        .then(data => {
            console.log("Devices fetched:", data);
            let deviceList = document.getElementById('device-list');
            deviceList.innerHTML = '';
            for (let id in data) {
                let device = data[id];
                const label = document.createElement('label');
                label.innerHTML = `<input type="checkbox" name="device" value="${id}"> ${device.device_name}`;
                deviceList.appendChild(label);
            }
        })
        .catch(error => console.error('Error fetching devices:', error));
}

function populateDeviceDropdown() {
    fetch('/api/get_all_devices')
        .then(response => response.json())
        .then(data => {
            let deviceDropdown = document.getElementById('device-name');
            deviceDropdown.innerHTML = '';
            for (let id in data) {
                let device = data[id];
                const option = document.createElement('option');
                option.value = id;
                option.textContent = device.device_name;
                deviceDropdown.appendChild(option);
            }
        })
        .catch(error => console.error('Error fetching devices for dropdown:', error));
}

document.querySelector('.add-to-devices').addEventListener('click', () => {
    let selectedPhotos = Array.from(document.querySelectorAll('input[name="photo"]:checked')).map(input => input.value);
    let selectedDevices = Array.from(document.querySelectorAll('input[name="device"]:checked')).map(input => input.value);

    if (selectedPhotos.length === 0 || selectedDevices.length === 0) {
        alert("Please select at least one photo and one device.");
        return;
    }

    console.log("Adding Photos to Devices", selectedPhotos, selectedDevices);

    fetch('/api/add_photos_to_devices', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            photo_ids: selectedPhotos,
            device_ids: selectedDevices
        })
    })
    .then(response => response.json())
    .then(data => {
        console.log("Add photos response:", data);
        if (data.success) {
            alert('Photos successfully added to devices');
        }
    })
    .catch(error => console.error('Error adding photos to devices:', error));
});

document.querySelector('.save-config').addEventListener('click', () => {
    let deviceName = document.getElementById('device-name').value;
    let photoUpdateFrequency = document.getElementById('photo-update-frequency').value;
    let randomOrder = document.getElementById('random-order').checked;

    let deviceConfig = {
        device_name: deviceName,
        photo_update_frequency: photoUpdateFrequency,
        random_order: randomOrder
    };

    console.log("Saving device configuration:", deviceConfig);

    fetch('/api/save_device_config', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(deviceConfig)
    })
    .then(response => response.json())
    .then(data => {
        console.log("Save response:", data);
        if (data.success) {
            alert('Device configuration saved successfully');
        }
    })
    .catch(error => console.error('Error saving device configuration:', error));
});

document.getElementById('device-name').addEventListener('change', () => {
    let deviceId = document.getElementById('device-name').value;
    if (deviceId) {
        getDeviceDetails(deviceId);
    } else {
        clearPreviewImage();
    }
});

function getDeviceDetails(deviceId) {
    fetch(`/api/get_device/${deviceId}`)
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                alert(data.error);
                return;
            }
            document.getElementById('photo-update-frequency').value = data.photo_update_frequency;
            document.getElementById('random-order').checked = data.random_order;
            
            let assignedPhotoList = document.getElementById('assigned-photo-list');
            assignedPhotoList.innerHTML = '';
            if (data.photos.length === 0) {
                clearPreviewImage(); // Clear the preview image
            } else {
                data.photos.forEach(photo => {
                    const label = document.createElement('label');
                    label.innerHTML = `<input type="radio" name="assigned-photo" value="${photo.photo_id}"> ${photo.photo_name}`;
                    label.querySelector('input').addEventListener('change', () => {
                        document.getElementById('assigned-photo-preview').src = photo.path;
                    });
                    assignedPhotoList.appendChild(label);
                });
                // Set the preview image to the first photo by default
                document.getElementById('assigned-photo-preview').src = data.photos[0].path;
            }
        })
        .catch(error => console.error('Error fetching device details:', error));
}

function clearPreviewImage() {
    document.getElementById('assigned-photo-preview').src = '';
}


################################################################################
File: ./static/style.css
/* General Styles */
body {
  font-family: 'Inter', sans-serif;
  margin: 0;
  padding: 0;
  background-color: #fff;
  text-align: center;
  display: flex;
  flex-direction: column;
}

/* Navbar Styles */
.navbar {
  display: flex;
  justify-content: space-around;
  padding: 20px;
  background-color: #d9d9d9;
  border-bottom: 4px solid #000;
  width: 100%;
  box-sizing: border-box;
  text-decoration: none;
}

.navbar-item {
  margin: 0;
  padding: 5px;
  font-size: 24px;
  font-weight: 800;
  cursor: pointer;
  transition: transform 0.3s ease, color 0.3s ease;
  text-decoration: none;
  color: inherit;
}

.navbar-item:hover {
  transform: scale(1.1);
  color: #ff6f61;
}

.highlight {
  background-color: #ffeb3b;
  padding: 5px;
  border-radius: 5px;
}

/* Main Content Styles */
.main-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 20px;
  gap: 10px;
  width: 100%;
  box-sizing: border-box;
}

.devices-section {
  width: 80%;
  border: 4px solid #000;
  padding: 20px;
  background-color: #d9d9d9;
  box-sizing: border-box;
}

.section-title {
  font-size: 24px;
  font-weight: 800;
  margin-bottom: 20px;
}

.device-list-header {
  display: flex;
  justify-content: space-around;
  padding: 10px 0;
  background-color: #ccc;
  border-bottom: 2px solid #000;
  font-weight: 800;
}

.device-list {
  margin-bottom: 20px;
}

.device-item {
  margin-bottom: 10px;
  font-size: 16px;
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 10px;
  padding: 10px;
  border-bottom: 1px solid #000;
}

.action-button {
  padding: 10px 20px;
  margin: 10px;
  border: none;
  background-color: #a9a9a9;
  font-size: 16px;
  cursor: pointer;
  transition: background-color 0.3s ease, transform 0.3s ease;
}

.action-button:hover {
  background-color: #8c8c8c;
  transform: scale(1.05);
}

/* Responsive Styles for Screens with max-width 768px */
@media screen and (max-width: 768px) {
  .navbar {
    flex-direction: row;
    align-items: center;
  }

  .navbar-item {
    font-size: 18px;
    margin: 10px 0;
  }

  .devices-section {
    width: 100%;
    padding: 10px;
  }

  .section-title {
    font-size: 20px;
  }

  .device-item,
  .action-button {
    font-size: 14px;
  }

  .device-list-header {
    flex-direction: row;
    align-items: center;
  }
}

/* Responsive Styles for Screens with max-width 600px */
@media screen and (max-width: 600px) {
  .device-list-header {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
  }

  .device-list-header p {
    font-size: 14px;
  }
}


################################################################################
File: ./static/app.js
// Object to store discovered Bluetooth devices
let discoveredDevices = {};

// Event listener for when the document content is loaded
document.addEventListener('DOMContentLoaded', () => {
    findWiFiDevices();
});

/**
 * Function to find new Bluetooth devices that are discoverable
 */
function findNewDevices() {
    fetch('/api/find_discoverable_bluetooth_devices')
        .then(response => response.json())
        .then(data => {
            discoveredDevices = data;
            let discoveredDevicesElement = document.getElementById('discovered-devices');
            if (discoveredDevicesElement) {
                discoveredDevicesElement.innerHTML = '';
                // Populate the discovered devices element with the names of found devices
                for (let mac in data) {
                    let device = data[mac];
                    discoveredDevicesElement.innerHTML += `<p>${device.device_name}</p>`;
                }
            } else {
                console.error('Element "discovered-devices" not found');
            }
        })
        .catch(error => console.error('Error finding new devices:', error));
}

/**
 * Function to invite discovered Bluetooth devices to join the network
 */
function inviteToNetwork() {
    fetch('/api/invite_to_network', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(Object.keys(discoveredDevices))
    })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                console.log("Devices successfully invited to network");
                findWiFiDevices();
            } else {
                console.log("Failed to invite devices");
            }
        })
        .catch(error => console.error("Error inviting devices:", error));
}

/**
 * Function to find devices connected to the WiFi network
 */
function findWiFiDevices() {
    fetch('/api/enumerate_wifi_devices')
        .then(response => response.json())
        .then(data => {
            let networkedDevices = document.getElementById('networked-devices');
            if (networkedDevices) {
                networkedDevices.innerHTML = '';
                // Populate the networked devices element with the details of connected devices
                for (let sn in data) {
                    let device = data[sn];
                    networkedDevices.innerHTML += `
                        <div class="device-item">
                            <p>${device.device_name}</p>
                            <p>${device.device_type}</p>
                            <p>${device.status}</p>
                            <p>${device.ip_address}</p>
                        </div>`;
                }
            } else {
                console.error('Element "networked-devices" not found');
            }
        })
        .catch(error => console.error('Error finding WiFi devices:', error));
}


################################################################################
File: ./static/style_photo_editor.css
/* General Styles */
body {
  font-family: 'Inter', sans-serif;
  margin: 0;
  padding: 0;
  background-color: #fff;
  text-align: center;
  display: flex;
  flex-direction: column;
}

/* Navbar Styles */
.navbar {
  display: flex;
  justify-content: space-around;
  padding: 20px;
  background-color: #d9d9d9;
  border-bottom: 4px solid #000;
  width: 100%;
  box-sizing: border-box;
}

.navbar-item {
  margin: 0;
  padding: 5px;
  font-size: 24px;
  font-weight: 800;
  cursor: pointer;
  text-decoration: none; /* Remove underline */
  color: inherit; /* Remove blue color */
  transition: transform 0.3s ease, color 0.3s ease;
}

.navbar-item:hover {
  transform: scale(1.1);
  color: #ff6f61;
}

.navbar-item.highlight {
  background-color: #ffeb3b;
  padding: 5px;
  border-radius: 5px;
}

/* Main Content Styles */
.main-content {
  display: flex;
  flex-direction: row;
  align-items: flex-start;
  justify-content: space-around;
  padding: 20px;
  gap: 20px;
  width: 100%;
  box-sizing: border-box;
}

.section-title {
  font-size: 24px;
  font-weight: 800;
  margin-bottom: 20px;
}

/* Photo Editor Specific Styles */
.photo-list-section,
.photo-display-panel {
  display: flex;
  flex-direction: column;
  align-items: center;
  border: 4px solid #000;
  padding: 20px;
  background-color: #d9d9d9;
  box-sizing: border-box;
  flex: 1;
}

.photo-list {
  display: flex;
  flex-direction: column;
  gap: 5px;
  margin-bottom: 20px;
}

.photo-controls {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 10px;
  margin-bottom: 20px;
}

.action-button {
  padding: 10px 20px;
  margin: 10px;
  border: none;
  background-color: #a9a9a9;
  font-size: 16px;
  cursor: pointer;
  transition: background-color 0.3s ease, transform 0.3s ease;
}

.action-button:hover {
  background-color: #8c8c8c;
  transform: scale(1.05);
}

.scale-input {
  width: 60px;
  text-align: center;
  padding: 5px;
  border: 1px solid #000;
}

/* Ensure the photo container maintains its aspect ratio */
.photo-container {
  position: relative;
  width: 80%;  /* Adjust the width as needed */
  height: 500px; /* Ensure the container takes a reasonable height */
  border: 2px solid #000;
  overflow: hidden;
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 0 auto; /* Center the container */
}

.preview-image {
  max-width: 100%;  /* Ensures the image does not exceed the container's width */
  max-height: 100%; /* Ensures the image does not exceed the container's height */
  object-fit: contain;  /* Keeps the aspect ratio of the image */
  position: absolute;  /* Use absolute positioning to center within the container */
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%); /* Center the image */
}


/* Responsive Styles */
@media screen and (max-width: 1200px) {
  .main-content {
    flex-direction: column;
    align-items: center;
  }

  .photo-list-section,
  .photo-display-panel {
    width: 100%;
  }

  .preview-image {
    max-width: 90%;  /* Adjust the width to be more responsive */
    max-height: 90%; /* Adjust the height to be more responsive */
  }
}

@media screen and (max-width: 768px) {
  .main-content {
    flex-direction: column;
    align-items: center;
    padding: 10px;
  }

  .photo-list-section,
  .photo-display-panel {
    width: 100%;
    padding: 10px;
  }

  .section-title {
    font-size: 20px;
  }

  .preview-image {
    max-width: 80%;  /* Adjust the width to be more responsive */
    max-height: 80%; /* Adjust the height to be more responsive */
  }

  .action-button {
    padding: 5px;
    font-size: 14px;
  }

  .scale-input {
    width: 50px;
  }
}

@media screen and (max-width: 480px) {
  .main-content {
    padding: 5px;
  }

  .photo-list-section,
  .photo-display-panel {
    padding: 5px;
  }

  .section-title {
    font-size: 14px;
  }

  .preview-image {
    max-width: 70%;  /* Adjust the width to be more responsive */
    max-height: 70%; /* Adjust the height to be more responsive */
  }

  .action-button {
    padding: 3px;
    font-size: 12px;
  }

  .scale-input {
    width: 40px;
  }
}

@media screen and (max-width: 768px) {
  .navbar-item {
    font-size: 18px;
    margin: 10px 0;
  }
}


################################################################################
File: ./templates/index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Meta tags for character encoding and viewport configuration -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- Link to Google Fonts for 'Inter' font family -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;800&display=swap">
    
    <!-- Link to external CSS file for styling -->
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}">

    
    <!-- Page title -->
    <title>Digital Photo Frame Ecosystem</title>
</head>
<body>
    <!-- Navbar section for navigation -->
    <header class="navbar">
        <a href="/" class="navbar-item highlight">DEVICE MANAGER</a>
        <a href="/device-editor" class="navbar-item">DEVICE EDITOR</a>
        <a href="/photo-editor" class="navbar-item">PHOTO EDITOR</a>
    </header>

    <!-- Main content area -->
    <main class="main-content">
        <!-- Discovered devices section -->
        <section class="devices-section">
            <h2 class="section-title">DISCOVERED DEVICES</h2>
            <div id="discovered-devices" class="device-list"></div>
            <button class="action-button" onclick="findNewDevices()">FIND NEW DEVICES</button>
            <button class="action-button" onclick="inviteToNetwork()">INVITE TO NETWORK</button>
        </section>

        <!-- Networked devices section -->
        <section class="devices-section">
            <h2 class="section-title">NETWORKED DEVICES</h2>
            <div class="device-list-header">
                <p>Device Name</p>
                <p>Device Type</p>
                <p>Status</p>
                <p>IP Address</p>
            </div>
            <div id="networked-devices" class="device-list"></div>
        </section>
    </main>

    <!-- Link to external JavaScript file for interactivity -->
    <script src="{{ url_for('static', filename='app.js') }}"></script>
</body>
</html>


################################################################################
File: ./templates/photo_editor.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;800&display=swap">
    <link rel="stylesheet" href="{{ url_for('static', filename='style_photo_editor.css') }}">
    <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}">

    <title>Photo Editor</title>
</head>
<body>
    <header class="navbar">
        <a href="/" class="navbar-item">DEVICE MANAGER</a>
        <a href="/device-editor" class="navbar-item">DEVICE EDITOR</a>
        <a href="/photo-editor" class="navbar-item highlight">PHOTO EDITOR</a>
    </header>
    <main class="main-content">
        <section class="photo-list-section">
            <h2 class="section-title">PHOTOS</h2>
            <div class="photo-list"></div>
            <form id="upload-form" enctype="multipart/form-data">
                <input type="file" name="file" id="file-input" accept="image/*">
                <button type="submit" class="action-button upload-button">UPLOAD NEW PHOTOS</button>
            </form>
        </section>
        <section class="photo-display-panel">
            <div class="photo-controls">
                <button class="action-button rotate-ccw">ROTATE CCW</button>
                <button class="action-button rotate-cw">ROTATE CW</button>
                <button class="action-button scale">SCALE</button>
                <input type="number" class="scale-input" value="100" min="10" max="100"><span>%</span>
                <button class="action-button save">SAVE</button>
            </div>
            <div class="split-screen-controls">
                <label for="split-screen-x">X:</label>
                <input type="number" class="split-screen-x" value="0" min="0">
                <label for="split-screen-y">Y:</label>
                <input type="number" class="split-screen-y" value="0" min="0">
                <label for="split-screen-width">Width:</label>
                <input type="number" class="split-screen-width" value="100" min="10">
                <label for="split-screen-height">Height:</label>
                <input type="number" class="split-screen-height" value="100" min="10">
            </div>
            <h2 class="section-title">Photo Display</h2>
            <div class="photo-container">
                <img src="" alt="Preview" class="preview-image">
                <div class="window-box"></div>
            </div>
        </section>
    </main>
    <script src="{{ url_for('static', filename='photo-editor-app.js') }}"></script>
</body>
</html>


################################################################################
File: ./templates/device_editor.html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;800&display=swap">
    <link rel="stylesheet" href="{{ url_for('static', filename='style_device_editor.css') }}">
    <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}">
    <title>Device Editor</title>
</head>

<body>
    <header class="navbar">
        <a href="/" class="navbar-item">DEVICE MANAGER</a>
        <a href="/device-editor" class="navbar-item highlight">DEVICE EDITOR</a>
        <a href="/photo-editor" class="navbar-item">PHOTO EDITOR</a>
    </header>

    <main class="main-content">
        <section class="photo-list-section">
            <h2 class="section-title">PHOTOS</h2>
            <div class="photo-list" id="photo-list">
                <!-- Photos will be dynamically populated here -->
            </div>
            <div class="preview">
                <h3>PREVIEW</h3>
                <div id="photo-previews"></div>
            </div>
        </section>

        <button class="action-button add-to-devices">ADD TO DEVICES</button>

        <section class="device-list-section">
            <h2 class="section-title">DEVICES</h2>
            <div class="device-list" id="device-list">
                <!-- Devices will be dynamically populated here -->
            </div>
        </section>

        <section class="device-config-pane">
            <h2 class="section-title">DEVICE CONFIGURATION</h2>
            <div class="config-item">
                <label for="device-name">Device Name:</label>
                <select id="device-name" name="device-name">
                    <!-- Options will be dynamically populated here -->
                </select>
            </div>
        
            <div class="config-item">
                <label for="photo-update-frequency">Photo Update Frequency (seconds):</label>
                <input type="number" id="photo-update-frequency" name="photo-update-frequency" min="0" max="999">
            </div>
            <div class="config-item">
                <label for="random-order">Randomize Order:</label>
                <input type="checkbox" id="random-order" name="random-order">
            </div>
            <div class="config-item">
                <h3>PAIRED PHOTOS</h3>
                <div class="assigned-photo-list" id="assigned-photo-list">
                    <!-- Paired photos will be dynamically populated here -->
                </div>
                <div class="button-group">
                    <button class="action-button move-up">MOVE UP</button>
                    <button class="action-button move-down">MOVE DOWN</button>
                    <button class="action-button remove">REMOVE</button>
                </div>
                <div class="preview">
                    <img src="" alt="Preview" class="preview-image" id="assigned-photo-preview">
                </div>
            </div>
            <button class="action-button save-config">SAVE DEVICE CONFIGURATION</button>
        </section>
        
    </main>

    <script src="{{ url_for('static', filename='device-editor-app.js') }}"></script>
</body>

</html>

